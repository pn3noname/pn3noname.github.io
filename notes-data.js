// notes-data.js
// ⚠️  이 파일은 GitHub Actions가 자동 생성합니다. 직접 수정하지 마세요.
// Generated: auto by scripts/build_notes.py

const notesData = [
  {
    "slug": "1-basics",
    "title": "1. Basics",
    "date": "2026-02-17",
    "category": "Algorithm",
    "tags": [
      "Algorithm",
      "Big O"
    ],
    "description": "알고리즘 기초 개념 정리",
    "content": "source: https://frontendmasters.com/courses/algorithms/binary-search-algorithm/\n\n# ==1. Big O Time Complexity==\n## 1) 기본 개념\n- Big O는 입력값에 따른 알고리즘의 시간이나 메모리를 분류하는 방법\n- 정확한 측정치가 아닌, 입력값이 증가함에 따라 알고리즘이 어떻게 반응하는지 이해하기 위한 일반화된 방법\n- 예를 들어, O(N)는 알고리즘이 입력값에 비례하여 선형적으로 증가한다는 의미\n\n## 2) Big O를 사용하는 이유\n- 특정 데이터 구조를 사용해야 하는지 결정하는 데 도움이 됨\n- 데이터 구조들은 점점 더 효율적으로 만들기 위해 제약 조건을 갖지만, 잘못 사용하면 성능이 크게 저하될 수 있음\n\n## 3) Big O의 중요 개념\n- 입력값에 대한 성장: 입력값이 증가할수록 계산 시간이나 메모리가 어떻게 증가하는지를 나타냄\n- 상수는 무시: 이론적으로 상수는 중요하지 않음\n\t- 예: O(10N) => O(N)\n- 최악의 경우 고려: 인터뷰에서는 주로 최악의 경우를 설명함\n\n> [!IMPORTANT]\n> ### 인터뷰에서 Big O의 최악의 경우를 주로 설명하는 이유?\n> 1. **신뢰성 보장**\n> \t- 최악의 경우를 고려하면 알고리즘이 어떤 상황에서도 특정 성능 기준을 충족할 것이라고 보장할 수 있음\n> \t- 이는 시스템의 안정성과 예측 가능성을 높임\n> 2. **에지 케이스 처리**\n> \t- 실제 환경에서는 예상치 못한 입력이나 상황이 발생할 수 있음\n> \t- 최악의 경우를 고려하면 이러한 에지 케이스에도 대응할 수 있는 알고리즘을 설계할 수 있음\n> 3. **리소스 계획**\n> \t- 시스템 설계 시 필요한 컴퓨팅 리소스(CPU, 메모리 등)를 계획할 때 최악의 경우를 고려해야 함\n> \t- 예를 들어, 웹 서비스가 순간적으로 트래픽이 폭증하는 상황에도 대응할 수 있어야 함\n> 4. **확인하기 쉬움**\n> \t- 최악의 경우는 일반적으로 정의하고 분석하기가 더 명확함\n> \t- 평균 케이스는 입력 분포에 따라 달라질 수 있어 더 복잡한 분석이 필요함\n> 5. **실용적 측면**\n> \t- 강의에서 언급했듯이, 강사는 약 200번의 인터뷰를 진행하고 50번의 인터뷰에 참여했지만 최선이나 평균 케이스를 묻는 경우는 거의 없었다고 함\n> \t- 이는 업계 관행에서 최악의 케이스가 더 중요하게 여겨진다는 것을 보여줌\n> \n> 예시를 들면:\n>\t- 문자열에서 특정 문자('E')를 찾는 알고리즘에서, 최악의 경우는 문자가 문자열의 끝에 있거나 아예 없는 경우로, 전체 문자열을 탐색해야 하므로 O(N)\n> \t- 최선의 경우는 문자가 첫 번째에 있어 O(1)이 되지만, 이런 이상적인 상황에만 의존할 수 없음\n> \n> 실제 소프트웨어 개발에서는 시스템이 최악의 상황에서도 견딜 수 있어야 하기 때문에, 인터뷰에서도 이런 관점에서 알고리즘을 평가하는 것\n\n> [!INFO]\n>### Edge Case와 Corner Case\n>#### 1. Edge Case\n> 엣지 케이스는 알고리즘이나 프로그램이 정상적인 동작 범위의 '가장자리(edge)'에 있는 입력이나 상황을 의미\n>##### 1) 특징\n> - 일반적인 사용 패턴에서 벗어나지만, 여전히 유효한 입력\n> - 기본 로직이 처리하지 못할 수 있는 경계값(boundary value)에 해당함\n> - 프로그램의 정상 동작 범위 내에서 예외적인 상황\n>#### 2) 예시\n> 1. **배열 처리**: 빈 배열, 단일 요소 배열\n> 2. **숫자 연산**: 0으로 나누기, 최대/최소 정수값 처리\n> 3. **문자열 처리**: 빈 문자열, 매우 긴 문자열\n> 4. **날짜 처리**: 윤년, 월말 날짜\n> 5. **사용자 입력**: 예상치 못한 형식의 입력(특수 문자, 이모지 등)\n> \n>#### 2. Corner Case\n> 코너 케이스는 여러 엣지 케이스가 동시에 발생하거나 더 극단적인 상황을 의미함\n> '코너(corner)'라는 이름은 여러 경계값이 만나는 지점, 즉 '모서리'에서 발생하는 케이스라는 의미에서 유래함\n>##### 1) 특징\n> - 여러 엣지 케이스의 조합으로 발생하는 더 복잡한 상황\n> - 매우 드물게 발생하지만, 발생 시 심각한 문제를 일으킬 수 있음\n> - 테스트하기 어려운 경우가 많음\n>##### 2) 예시\n> 1. **웹 애플리케이션**: 네트워크 연결이 불안정한 상태에서 대용량 파일 업로드\n> 2. **모바일 앱**: 배터리가 거의 없는 상태에서 GPS와 카메라를 동시에 사용\n> 3. **데이터베이스**: 최대 연결 수에 도달한 상태에서 대량의 트랜잭션 처리\n> 4. **알고리즘**: 정렬 알고리즘에서 이미 정렬된 역순 배열 처리\n> 5. **UI**: 매우 작은 화면에서 복잡한 대화상자 표시\n> \n>#### 3. 두 개념의 차이점\n>##### 1) **범위와 복잡성**\n> - 엣지 케이스: 단일 변수나 조건의 경계값\n> - 코너 케이스: 여러 변수나 조건의 경계값이 동시에 발생\n>##### 2) **발생 빈도**\n> - 엣지 케이스: 상대적으로 더 자주 발생\n> - 코너 케이스: 매우 드물게 발생\n>##### 3) **예측 가능성**\n> - 엣지 케이스: 비교적 예측하기 쉬움\n> - 코너 케이스: 예측하기 어려움\n> \n>#### 4. 소프트웨어 개발에서의 중요성\n>1) 견고한 시스템 구축: 엣지 케이스와 코너 케이스를 처리하면 더 안정적인 소프트웨어를 만들 수 있음\n>2) 버그 예방: 이러한 케이스를 미리 고려하면 나중에 발생할 수 있는 심각한 오류를 예방할 수 있음\n>3) 사용자 경험 향상: 예상치 못한 상황에서도 적절히 대응하여 사용자 만족도를 높일 수 있음\n>4) 유지보수 비용 절감: 사후에 발견되는 버그를 수정하는 것보다 개발 단계에서 이러한 케이스를 고려하는 것이 비용 효율적임\n> \n>엣지 케이스와 코너 케이스를 철저히 테스트하고 처리하는 것은 고품질 소프트웨어 개발의 핵심 요소\n> \n\n## 4) 일반적인 복잡도\n\n- O(1): 상수 시간 - 입력 크기와 관계없이 항상 동일한 작업 수행\n- O(log N): 로그 시간 - 이진 검색 등의 알고리즘\n- O(N): 선형 시간 - 입력 크기에 비례하여 증가\n- O(N log N): 퀵소트와 같은 정렬 알고리즘\n- O(N²): 제곱 시간 - 이중 반복문 등\n- O(N³): 세제곱 시간 - 행렬 곱셈 등\n- O(2^N), O(N!): 실용적이지 않은 알고리즘\n\n## 5) 복잡도 파악하는 법\n- 반복문을 찾기: 입력값에 대해 어떻게 반복하는지 확인하는 것이 가장 쉬운 방법\n- 예: 문자열의 길이만큼 반복하는 반복문은 O(N)\n- 중첩 반복문은 각 차원에 따라 복잡도가 증가 (예: 이중 반복문은 O(N²))\n\n## 6) 공간 복잡도\n- 시간 복잡도만큼 자주 논의되지는 않지만, 특정 상황에서는 중요할 수 있음\n- 알고리즘이 사용하는 메모리가 입력값에 따라 어떻게 증가하는지를 나타냄\n\n## 7) 퀵소트, 링 버퍼(실용적으로 유용함)"
  }
];
