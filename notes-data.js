// notes-data.js
// ⚠️  이 파일은 GitHub Actions가 자동 생성합니다. 직접 수정하지 마세요.
// Generated: auto by scripts/build_notes.py

var notesData = [
  {
    "slug": "2-search",
    "title": "Search Algorithms 101",
    "date": "2026-02-18",
    "category": "Algorithm",
    "tags": [
      "Linear Search",
      "Binary Search",
      "Two Crystal Balls Problem",
      "Greedy Algorithm"
    ],
    "description": "Covers linear search, binary search, and the Two Crystal Balls problem, along with an introduction to greedy algorithms. Includes pseudocode, implementation details, and complexity analysis for each approach.",
    "content": "source: https://frontendmasters.com/courses/algorithms/binary-search-algorithm/\n\n# 1. Linear Search\n## 1. 기본 개념\n- 선형 검색은 가장 기본적인 검색 알고리즘\n- 배열이나 리스트의 처음부터 끝까지 순차적으로 모든 요소를 확인하면서 원하는 값을 찾는 방식\n\n## 2. 특징\n- 구현이 매우 간단함\n- 정렬되지 않은 데이터에서도 사용 가능\n- 시간 복잡도: O(n) -> 최악의 경우 모든 요소를 확인해야 함\n- 공간 복잡도: O(1) -> 추가 메모리가 거의 필요 없음\n\n## 3. 동작 과정\n### 1. 배열의 첫 번째 요소부터 시작\n### 2. 현재 요소가 찾는 값인지 확인\n### 3. 맞다면 해당 위치 반환, 아니면 다음 요소로 이동\n### 4. 배열 끝까지 반복하며 값을 찾지 못하면 \"찾을 수 없음\" 반환\n\n\n# 2. Binary Search\n## 1. 기본 개념\n- 이진 검색은 정렬된 배열에서 사용할 수 있는 효율적인 검색 알고리즘\n- 중간 요소를 확인하고 찾는 값이 중간값보다 작은지 큰지에 따라 검색 범위를 절반으로 줄여나가는 방식\n\n## 2. 특징\n- 정렬된 데이터에서만 사용 가능\n- 선형 검색보다 훨씬 빠름\n- 시간 복잡도: O(log n) -> 매 단계마다 검색 범위가 절반으로 줄어듦\n- 공간 복잡도: 반복적 구현 시 O(1), 재귀적 구현 시 O(log n)\n\n## 3. 동작 과정\n### 1. 배열의 중간 요소를 확인\n### 2. 중간 요소가 찾는 값과 일치하면 해당 위치 반환\n### 3. 찾는 값이 중간 요소보다 작으면 왼쪽 절반에서 검색 계속\n### 4. 찾는 값이 중간 요소보다 크면 오른쪽 절반에서 검색 계속\n### 5. 범위가 더 이상 없을 때까지 반복하고, 찾지 못하면 \"찾을 수 없음\" 반환\n\n> [!INFO]\n> # 두 알고리즘의 비교\n> 예를 들어, 100만 개의 요소가 있는 배열에서 선형 검색은 최악의 경우 100만 번의 비교가 필요하지만, 이진 검색은 최대 약 20번의 비교만으로 찾을 수 있음\n> \n> <img width=\"627\" height=\"178\" alt=\"image\" src=\"https://github.com/user-attachments/assets/ab27def9-21c1-4ee6-85a9-d7b4e04999d6\" />\n\n\n## 4. 알고리즘 구현 방법\n### 1. 주요 변수\n- `lo`: 탐색 시작 지점 (포함)\n- `hi`: 탐색 끝 지점 (미포함)\n- `mid`: 중간 지점 인덱스\n- `array`: 탐색할 정렬된 배열\n- `needle`: 찾고자 하는 값\n\n### 2. 의사코드 (Pseudocode)\n```\nfunction search(array, lo, hi, needle):\n\tdo:\n\t\tmid = lo + (hi - lo) / 2     // 중간 지점 계산\n\t\tvalue = array[mid].          // 중간 지점의 값 가져오기\n\n\t\tif value == needle:          // 값을 찾았을 경우\n\t\t\treturn true (또는 mid)\n\t\telse if value < needle:      // 찾는 값이 중간값보다 클 경우\n\t\t\tlo = mid + 1             // 오른쪽 부분 배열 탐색\n\t\telse:\n\t\t\thi = mid                 // 왼쪽 부분 배열 탐색\n\t\twhile lo < hi                // 탐색 범위가 유효할 때까지 반복\n\n\t\treturn false (또는 -1)        // 값을 찾지 못했을 경우\n```\n\n### 3. 중요 포인트\n#### 1. 항상 정렬된 배열에서만 사용해야 함\n#### 2. `lo`는 포함 (inclusive), `hi`는 미포함 (exclusive)으로 처리함\n#### 3. 종료 조건은 `lo < hi`가 아닐 때임 (탐색 범위가 없어질 때)\n#### 4. 값을 찾지 못했을 경우, -1이나 false를 반환하는데, 이를 '센티넬 (sentinel) 값'이라고 부름\n\n\n> [!INFO]\n> # sentinel 값\n> ## 사용 목적\n> ### 1. 데이터 종료 표시\n> - 데이터 스트림이나 배열, 리스트 등의 끝을 나타내기 위해 사용됨\n> - 예: c언어에서 문자열의 끝을 나타내는 널 (NULL) 문자 ('\\0')가 대표적인 센티넬 값\n> ### 2. 특별한 상태 표시\n> - 특정 함수나 알고리즘에서 특별한 상태나 조건을 나타내기 위해 사용됨\n> - 일반적인 데이터 값과는 구분되는 특수한 값을 사용함\n> ### 3. 오류 상태 표시\n> - 함수가 실패했거나 비정상적인 상황이 발생했음을 나타내기 위해 사용됨\n> - 예: 많은 함수에서 -1이나 NULL을 반환하여 오류를 표시함\n>\n> - 센티넬 값은 일반적으로 해당 데이터 타입에서 실제 데이터로는 거의 사용되지 않을 값을 선택함\n> - 이는 일반 데이터와 센티넬 값 사이의 충돌을 방지하기 위함\n> - 예:\n> \t- 정수형 데이터에서 -1이나 최대값 (MAX_INT) 등을 센티넬 값으로 사용\n> \t- 포인터에서는 NULL을 센티넬 값으로 사용\n> \t- 문자열에서 특수 문자를 센티넬 값으로 사용\n> - 센티넬 값은 알고리즘의 흐름을 제어하거나 특별한 케이스를 표시하는 데 매우 유용한 프로그래밍 기법\n\n## 5. 이진 검색 구현\n### 1. 기본 설정\n- 함수는 'haystack (배열)'과 'needle (찾고자 하는 값)'을 매개변수로 받음\n- 반복문으로 do-while 루프 사용 (다른 반복문도 사용 가능)\n- 초기 변수 설정: lo=0 (시작점), \bhi=haystack.length (끝점)\n\n### 2. 핵심 로직\n- 중간점 (midpoint) 계산: `const m = Math.floor((lo + hi - l) / 2)`\n  - warning! 2로 나누는 것을 잊지 말 것!\n- 현재 중간값 가져오기: `const value = haystack[m]`\n- 반복 조건: `while (lo < hi)`\n\n### 3. 검색 조건 처리\n- 중간값이 찾는 값과 같은 때: `value === needle`이면 `return true`로 찾았음을 반환\n- 중간값이 찾는 값보다 클 때: `value > needle`이면 오른쪽 부분은 모두 큰 값이므로 `hi = m`으로 검색 범위 축소\n- 중간값이 찾은 값보다 작을 때: 그 외의 경우 (else)에는 `lo = m + 1`로 왼쪽 부분 제외\n\n> [!IMPORTANT]\n> # `lo = m + 1`인 이유\n> ## 1. 현재 중간값 `m`은 이미 확인했음: `value < needle`이므로 `m` 위치의 값은 우리가 찾는 값이 아님\n> ## 2. 중간값보다 작은 모든 값들도 제외: 배열이 정렬되어 있으므로, `m`보다 왼쪽에 있는 모든 값들 (`lo`부터 `m`까지)은 우리가 찾는 값보다 작음\n> ## 3. lo는 inclusive이므로: 다음 검색 범위에서 `m+1`부터 시작해야 함\n> - 만약 `lo = m`으로 설정하면, 다음 반복에서 또 같은 `m` 값을 확인하게 되어 무한루프 위험\n> \n> 예:\n> ```\n> 배열: [1, 3, 5, 7, 9], needle = 7\n> lo = 0, hi = 5, m = 2, value = 5\n> 5 < 7이므로 오른쪽 절반을 검색해야 함\n> lo = m + 1 = 3 (인덱스 3부터 시작 = 값 7부터)\n> ```\n> \n> 반대로 `hi = m`에서는 +1을 하지 않는 이유:\n> - hi는 exclusive이므로 `m`을 포함하지 않음\n> - 이미 `m`을 제외한 범위가 됨\n> \n> 위의 내용이 이진 검색에서 흔히 발생하는 \"off-by-one error\"를 피하는 핵심\n\n> [!INFO]\n> # Off-by-one error\n> - 프로그래밍에서 가장 흔한 실수 중 하나로, 인덱스나 카운터를 1만큼 잘못 계산하는 오류\n> - 정확하게 처리하지 않으면 무한루프나 잘못된 결과를 만들어내는 까다로운 버그\n> \n> ## 1. 배열 인덱스 실수\n> ```javascript\n> // 잘못된 예: off-by-one error\n> const arr = [1, 2, 3, 4, 5];\n> for (let i = 1; i <= arr.length; i++) { // 1부터 시작, <= 사용\n> \tconsole.log(arr[i]); // 2, 3, 4, 5, undefined (마지막에 오류)\n> }\n> \n> // 올바른 예\n> for (let i = 0; i < arr.length; i++) { // 0부터 시작, < 사용\n> \tconsole.log(arr[i]); // 1, 2, 3, 4, 5\n> }\n> ```\n> \n> ## 2. 이진 검색에서의 off-by-one error\n> ```javascript\n> // 문제가 될 수 있는 경우들\n> lo = m;                      // m을 다시 포함시켜 무한루프 위험\n> hi = m + 1;                // 경계를 잘못 설정\n> ```\n> \n> ## 3. 일상적인 예시들\n> - 문자열 길이: \"Hello\"의 길이는 5이지만, 마지막 문자의 인덱스는 4\n> - 반복문 범위: 10번 반복하려면 `i < 10`이어야 하는데, `i <= 10`으로 써서 11번 반복\n> - 날짜 계산: 1월 1일부터 1월 5일까지는 5일이 아니라 4일 차이\n> \n> ## 4. 왜 이진 검색에서 중요한가?\n> ```javascript\n> // 만약 lo = m으로 했다면\n> lo = 0, hi = 2, m = 1\n> lo = m = 1           // 다음에 또 m = 1이 나올 수 있음 -> 무한루프\n> \n> // lo = m + 1로 하면\n> lo = m + 1 = 2     // 확실히 범위가 줄어듦\n> ```\n\n### 4. 코드\n```javascript\n// haystack: number[]\n// needle: number\n\nlet lo = 0;\nlet hi = haystack.length - 1;\n\nwhile (lo <= hi) {\n\tlet m = Math.floor((lo + hi) / 2);\n\n\tif (needle === haystack[m]) {\n\t\treturn true;\n\t}\n\telse if (needle < haystack[m]) {\n\t\thi = m - 1;\n\t}\n\telse {\n\t\tlo = m + 1;\n\t}\n\treturn false;\n}\n```\n\n# 3. Two Crystal Balls Problem\n## 1. 문제 설명\n- 특정 높이에서 떨어뜨리면 깨지는 두 개의 수정구슬\n- 이 구슬들이 정확히 어느 지점에서 깨지는지를 가장 효율적인 방법으로 찾아야 함\n- 예: 100층 건물에서 몇 층부터 구슬이 깨지는지 찾는 문제\n\n## 2. 문제의 본질 (일반화)\n- 거짓 (false)들로 가득한 배열이 있고\n- 어느 지점부터는 참 (true)이 되어 계속 참을 유지\n- 이 전환점을 찾는 것이 목표\n\n## 3. 기존 접근법들의 한계\n### 1. 선형 탐색 (Linear Search)\n- 처음부터 하나씩 확인\n- 시간복잡도: O(N)\n- 두 번째 구슬을 전혀 활용하지 못함\n\n### 2. 이진 탐색 (Binary Search)\n- 중간 지점부터 시작\n- 만약 중간에서 깨진다면? -> 구슬 하나 소모\n- 나머지 구슬로는 처음부터 선형 탐색 해야 함\n- 결국 최악의 경우 O(N)\n\n## 4. 최적해: √N 접근법\n- 제곱근 단위로 점프하기\n\n### 1. 알고리즘 과정\n#### 1. √N만큼 점프하면서 첫 번째 구슬로 테스트\n#### 2. 구슬이 깨질 때까지 계속 점프\n#### 3. 깨지면 마지막으로 안전했던 지점으로 돌아가기\n#### 4. 두 번재 구슬로 선형적으로 탐색 (최대 √N 거리)\n\n### 2. 시간복잡도 분석\n- 점프 횟수: 최대 √N번\n- 선형 탐색: 최대 √N번\n- 총 시간복잡도: √N + √N = 2√N = O(√N)\n\n### 3. 핵심 아이디어\n- 기존 이진 탐색이 N/2 단위로 점프하여 문제가 생겼다면, √N 단위로 점프함으로써 두 구슬을 모두 효과적으로 활용할 수 있게 됨\n- 이는 선형 탐색 O(N)보다 훨씬 효율적이면서도, 제약 조건 (구슬 2개)을 잘 활용한 창의적인 해결책\n\n\n> [!QUESTION]\n> # 수정구슬이 하나만 있어도 같은 알고리즘이 작동하지 않을까?\n> ## 1. 수정구슬이 하나만 있을 때의 문제점\n> - 수정구슬이 하나뿐이라면, 유일한 방법은 선형 탐색 (Linear Search)\n> - 1층부터 차례대로 올라가면서 테스트\n> - 구슬이 깨질 때까지 한 층씩 확인\n> - 시간복잡도: O(N) -> 매우 비효율적\n> ## 2. 왜 √N 알고리즘에는 두 개가 필요한가?\n> - √N 알고리즘이 작동하는 핵심은 두 단계 과정\n> ### 1. 1단계: 첫 번째 구슬로 √N씩 점프\n> - √N 간격으로 큰 점프를 하며 테스트\n> - 구슬이 깨질 때까지 여러 층을 건너뛰기\n> ### 2. 2단계: 두 번째 구슬로 정확한 지점 찾기\n> - 첫 번째 구슬이 깨진 후\n> - 마지막 안전한 층으로 돌아가서\n> - 두 번째 구슬로 선형 탐색 (최대 √N 범위)\n>\n> ## 3. 핵심 포인트\n> - √N만큼 점프한다는 것은 특정 수의 층을 건너뛴다 (skipping)는 의미\n> - 수정구슬 중 하나가 깨지면, 목표 층이 마지막 '안전한' 층과 현재 층 사이 어딘가에 있다는 것을 알 수 있음\n> - 그래서 그 안전한 층부터 선형 탐색을 통해 목표 층을 찾는 것\n> ## 4. 결론\n> - 구슬 1개: 처음부터 끝까지 선형 탐색만 가능 -> O(N)\n> - 구슬 2개: 점프 + 정밀 탐색의 조합 가능 -> O(√N)\n> - 두 번째 구슬이 있기 때문에 실험적으로 큰 점프를 시도할 수 있고, 실패해도 다시 정밀하게 찾기가 가능한 것임\n\n## 5. Crystal Ball Problem 알고리즘 구현\n### 1. 문제 개요\n- 높은 건물에서 수정구를 떨어뜨릴 때, 어느 층부터 깨지는지 찾는 문제\n- 배열로 표현: `[false, false, false, true, true, ture]` (false=안 깨짐, true=깨짐)\n- 목표: 수정구가 처음으로 깨지는 층 (인덱스)을 찾기\n\n### 2. 왜 이진 탐색이 안 되는가?\n- 이진 탐색으로 중간 지점에서 수정구를 떨어뜨렸는데 깨졌다면?\n- 남은 수정구가 1개 뿐이므로, 처음부터 그 지점까지 선형적으로 하나씩 확인해야 함\n- 결국 최악의 경우 N/2만큼 확인해야 하므로 여전히 선형 시간\n\n### 3. 해결책: √N 점프 알고리즘\n#### 1. 핵심 아이디어\n##### 1. 첫 번째 수정구: √N만큼 점프하면서 깨지는 지점 찾기\n##### 2. 두 번째 수정구: 깨진 지점에서 √N만큼 뒤로 돌아가서 선형 탐색\n\n#### 2. 알고리즘 단계 (코드)\n```javascript\nexport default function two_crystal_balls(breaks: boolean[]): number {\n\t// breaks 배열의 의미\n\t// breaks[i] = true: i층에서 크리스탈 볼이 깨짐\n\t// breaks[i] = false: i층에서 크리스탈 볼이 안전함\n\n\tconst jmpAmount = Math.floor(Math.sqrt(breaks.length));\n\n\tlet i = jmpAmount;\n\tfor (; i < breaks.length; i += jmpAmount) {\n\t\tif (breaks[i]) { // breaks[i]가 true라면 (= if (breaks[i] === true))\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ti -= jmpAmount; // 마지막으로 안전했던 층으로 돌아감\n\n\t// 안전했던 층부터 시작해서 한 층씩 올라가며 탐색\n\tfor (let j = 0; j <- jmpAmount && i < breaks.length; ++j, ++i) {\n\t\tif (breaks[i]) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n```\n\n### 4. 시간 복잡도 분석\n#### 1. 최악의 경우\n##### 1. 첫 번째 단계: √N번 점프\n##### 2. 두 번째 단계: √N번 선형 탐색\n##### 3. 총 시간 복잡도: O(√N + √N) = O(√N)\n\n#### 2. 왜 √N이 최적인가?\n- √N보다 작게 점프하면: 점프 횟수가 증가\n- √N보다 크게 점프하면: 선형 탐색 구간이 증가\n- √N이 두 구간의 균형점\n\n### 5. 다른 루트 값들과의 비교\n- 세제곱근(∛N): 점프 거리는 줄어들지만 점프 횟수가 증가하여 비효율적\n- 네제곱근이나 더 높은 루트: 선형 탐색에 가까워져서 비효율적\n- √N이 최적의 균형점\n\n### 6. 핵심 포인트\n#### 1. 이진 탐색은 수정구 문제에서 선형 시간이 됨\n#### 2. √N 점프로 O(√N) 시간 복잡도 달성\n#### 3. 첫 번째 수정구로 대략적 위치 파악, 두 번째로 정확한 위치 찾기\n#### 4. √N이 점프 거리와 선형 탐색 거리의 최적 균형점\n\n\n> [!INFO]\n> # 탐욕적 접근법 (Greedy Algorithm)\n> - 매 순간 가장 좋아 보이는 선택을 하는 알고리즘 설계 기법\n> ## 1. 탐욕적 접근법의 특징\n> ### 1. 핵심 원리\n> - 현재 상황에서 최선의 선택을 함\n> - 미래의 결과를 고려하지 않음\n> - 지역적 최적해 (local optimum)를 선택해서 전역적 최적해 (global optimum)를 찾으려 함\n> ### 2. 일반적인 절차\n> #### 1. 선택: 현재 상황에서 최선의 선택을 한다\n> #### 2. 적용: 선택한 것을 현재 해에 추가한다\n> #### 3. 확인: 문제가 해결되었는지 확인한다\n> #### 4. 반복: 해결되지 않았다면 1단계로 돌아간다\n> \t\n> ## 2. 대표적인 예시들\n> ### 거스름돈 문제\n> ```typescript\n> // 730원을 거슬러 줄 때 (동전: 500원, 100원, 50원, 10원)\n> function makeChange (amount: number): number[] {\n> \tconst coin = [500, 100, 50, 10];\n> \tconst result = [];\n> \tamount = 730;\n> \t\n> \tfor (const coin of coins) {\n> \t\twhile (amount >= coin) {\n> \t\t\tresult.push(coin); // 사용한 동전을 배열의 끝에 추가\n> \t\t\tamount -= coin; // 탐욕적 선택: 가장 큰 동전부터\n> \t\t}\n> \t}\n> \treturn result; // [500, 100, 100, 10, 10, 10]\n> }\n> ```\n> ### 활동 선택 문제\n> #### 1. 시각적 표현\n> 시간:  0   1   2   3   4   5   6   7   8   9\n> 활동A:        [----A----]\n> 활동B:             [--B--]                        (A와 겹침 - 제외)\n> 활동C:   [--------C--------]             (A,D와 겹침 - 제외)\n> 활동D:                        [--D--]             (선택)\n> 활동E:                                   [E]          (선택)\n> 활동F:                         [----F----]      (D,E와 겹침 - 제외)\n> 선택됨:        [----A----]  [--D--]  [E]\n> #### 2. 문제 상황\n> - 한 개의 강의실이 있고, 여러 활동들이 각각 시작 시간과 끝나는 시간을 가지고 있음\n> - 겹치지 않으면서 최대한 많은 활동을 선택해야 함\n> #### 3. 구체적인 예시\n> ```typescript\n> const activities = [\n> \t{ name: 'A', start: 1, end: 4 }, // 1시~4시 \n> \t{ name: 'B', start: 3, end: 5 }, // 3시~5시 \n> \t{ name: 'C', start: 0, end: 6 }, // 0시~6시 \n> \t{ name: 'D', start: 5, end: 7 }, // 5시~7시 \n> \t{ name: 'E', start: 8, end: 9 }, // 8시~9시 \n> \t{ name: 'F', start: 5, end: 9 } // 5시~9시\n> ];\n> ```\n> #### 4. 알고리즘 단계별 실행\n> ##### 1. 끝나는 시간 순으로 정렬\n> ```typescript\n> activities.sort((a, b) => a.end - b.end);\n> ```\n>\n> 정렬 후:\n> ```typescript\n> const activities = [\n> \t{ name: 'A', start: 1, end: 4 }, // 4시 끝\n> \t{ name: 'B', start: 3, end: 5 }, // 5시 끝\n> \t{ name: 'C', start: 0, end: 6 }, // 6시 끝\n> \t{ name: 'D', start: 5, end: 7 }, // 7시 끝 \n> \t{ name: 'E', start: 8, end: 9 }, // 9시 끝\n> \t{ name: 'F', start: 5, end: 9 } // 9시 끝\n> ];\n> ```\n> ##### 2. 탐욕적 선택 과정\n> ```typescript\n>\tfunction activitySelection(activities) { \n>\t\tactivities.sort((a, b) => a.end - b.end); \n>\t\tconst result = [activities[0]]; // 첫 번째 활동은 무조건 선택 \n>\t\tlet lastEnd = activities[0].end; \n>\t\tfor (let i = 1; i < activities.length; i++) { \n>\t\t\tif (activities[i].start >= lastEnd) { \n>\t\t\t\tresult.push(activities[i]); \n>\t\t\t\tlastEnd = activities[i].end; \n>\t\t\t} \n>\t\t} \n>\t\treturn result; \n>\t}\n> ```\n> \n> ```\n>  ![[Pasted image 20250601170931.png]]\n>  ![[Pasted image 20250601170954.png]]\n>  ```\n> ```typescript\n> \t// 가장 많은 활동을 선택하기\n> \tfunction activitySelection (activities: {start: number, end: number} [] ) {\n> \t\tactivities.sort((a, b) => a.end - b.end); // 끝나는 시간 순 정렬\n> \t\t\n> \t\tconst result = [activities[0]]; // 첫 번재 활동은 무조건 선택\n> \t\tlet lastEnd = activities[0].end;\n> \t\t\n> \t\tfor (let i = 1; i < activities.length; i++) {\n> \t\t\tif (activities[i].start >= lastEnd) { // 탐욕적 선택: 가장 빨리 끝나는 것\n> \t\t\t\tresult.push(activities[i]);\n> \t\t\t\tlastEnd = activities[i].end;\n> \t\t\t}\n> \t\t}\n> \t\treturn result;\n> \t}\n> ```\n\n#### 3. Two Crystal Balls에서의 탐욕적 접근\n##### 탐욕적 선택들:\n1. √n 간격으로 점프: 가장 효율적인 간격\n2. 깨지면 즉시 중단: 불필요한 테스트 피하기\n3. 이전 안전 지점부터 선형 탐색: 확실한 구간에서만 탐색\n##### 각 단계에서의 \"탐욕적\" 판단:\n1. 1단계: \"지금 당장 가장 빠르게 구간을 좁힐 수 있는 방법은?\"\n2. 2단계: \"남은 볼 1개로 가장 확실하게 찾을 수 있는 방법은?\"\n\n#### 4. 탐욕법의 장단점\n##### 1. 장점\n- 구현이 간단\n- 속도가 빠름\n- 직관적으로 이해하기 쉬움\n##### 2. 단점\n- 항상 최적해를 보장하지 않음\n- 문제에 따라 적용 불가능\n##### 3. 탐욕법이 최적해를 보장하는 조건\n1. 탐욕적 선택 속성: 지역적 최적 선택이 전역적 최적해로 이어짐\n2. 최적 부분 구조: 문제의 최적해가 부분 문제의 최적해를 포함\n##### 4. Two Crystal Balls 문제에서 탐욕법을 쓰는 이유는 √n 간격이 수학적으로 최적이라는 것이 증명되어있기 때문\n\n#### 5. 다른 접근법과의 비교\n<img width=\"535\" height=\"145\" alt=\"image\" src=\"https://github.com/user-attachments/assets/6098f89b-294e-4ff4-9008-3030188e221a\" />"
  },
  {
    "slug": "1-basics",
    "title": "Basics of Algorithm",
    "date": "2026-02-17",
    "category": "Algorithm",
    "tags": [
      "Algorithm",
      "Big O"
    ],
    "description": "An introduction to Big O time complexity — how to classify algorithms by their growth rate, why worst-case analysis matters in interviews, and the difference between edge cases and corner cases.",
    "content": "source: https://frontendmasters.com/courses/algorithms/binary-search-algorithm/\n\n# 1. Big O Time Complexity\n## 1. 기본 개념\n- Big O는 입력값에 따른 알고리즘의 시간이나 메모리를 분류하는 방법\n- 정확한 측정치가 아닌, 입력값이 증가함에 따라 알고리즘이 어떻게 반응하는지 이해하기 위한 일반화된 방법\n- 예를 들어, O(N)는 알고리즘이 입력값에 비례하여 선형적으로 증가한다는 의미\n\n## 2. Big O를 사용하는 이유\n- 특정 데이터 구조를 사용해야 하는지 결정하는 데 도움이 됨\n- 데이터 구조들은 점점 더 효율적으로 만들기 위해 제약 조건을 갖지만, 잘못 사용하면 성능이 크게 저하될 수 있음\n\n## 3. Big O의 중요 개념\n- 입력값에 대한 성장: 입력값이 증가할수록 계산 시간이나 메모리가 어떻게 증가하는지를 나타냄\n- 상수는 무시: 이론적으로 상수는 중요하지 않음\n\t- 예: O(10N) => O(N)\n- 최악의 경우 고려: 인터뷰에서는 주로 최악의 경우를 설명함\n\n> [!IMPORTANT]\n> # 인터뷰에서 Big O의 최악의 경우를 주로 설명하는 이유?\n> ## 1. 신뢰성 보장\n> - 최악의 경우를 고려하면 알고리즘이 어떤 상황에서도 특정 성능 기준을 충족할 것이라고 보장할 수 있음\n> - 이는 시스템의 안정성과 예측 가능성을 높임\n> ## 2. 에지 케이스 처리\n> - 실제 환경에서는 예상치 못한 입력이나 상황이 발생할 수 있음\n> - 최악의 경우를 고려하면 이러한 에지 케이스에도 대응할 수 있는 알고리즘을 설계할 수 있음\n> ## 3. 리소스 계획\n> - 시스템 설계 시 필요한 컴퓨팅 리소스(CPU, 메모리 등)를 계획할 때 최악의 경우를 고려해야 함\n> - 예를 들어, 웹 서비스가 순간적으로 트래픽이 폭증하는 상황에도 대응할 수 있어야 함\n> ## 4. 확인하기 쉬움\n> - 최악의 경우는 일반적으로 정의하고 분석하기가 더 명확함\n> - 평균 케이스는 입력 분포에 따라 달라질 수 있어 더 복잡한 분석이 필요함\n> ## 5. 실용적 측면\n> - 강의에서 언급했듯이, 강사는 약 200번의 인터뷰를 진행하고 50번의 인터뷰에 참여했지만 최선이나 평균 케이스를 묻는 경우는 거의 없었다고 함\n> - 이는 업계 관행에서 최악의 케이스가 더 중요하게 여겨진다는 것을 보여줌\n> \n> 예시를 들면:\n> - 문자열에서 특정 문자('E')를 찾는 알고리즘에서, 최악의 경우는 문자가 문자열의 끝에 있거나 아예 없는 경우로, 전체 문자열을 탐색해야 하므로 O(N)\n> - 최선의 경우는 문자가 첫 번째에 있어 O(1)이 되지만, 이런 이상적인 상황에만 의존할 수 없음\n> \n> 실제 소프트웨어 개발에서는 시스템이 최악의 상황에서도 견딜 수 있어야 하기 때문에, 인터뷰에서도 이런 관점에서 알고리즘을 평가하는 것\n\n> [!INFO]\n> # Edge Case와 Corner Case\n> ## 1. Edge Case\n> - 엣지 케이스는 알고리즘이나 프로그램이 정상적인 동작 범위의 '가장자리(edge)'에 있는 입력이나 상황을 의미\n> ### 1. 특징\n> - 일반적인 사용 패턴에서 벗어나지만, 여전히 유효한 입력\n> - 기본 로직이 처리하지 못할 수 있는 경계값(boundary value)에 해당함\n> - 프로그램의 정상 동작 범위 내에서 예외적인 상황\n> ### 2. 예시\n> #### 1. 배열 처리: 빈 배열, 단일 요소 배열\n> #### 2. 숫자 연산: 0으로 나누기, 최대/최소 정수값 처리\n> #### 3. 문자열 처리: 빈 문자열, 매우 긴 문자열\n> #### 4. 날짜 처리: 윤년, 월말 날짜\n> #### 5. 사용자 입력: 예상치 못한 형식의 입력(특수 문자, 이모지 등)\n> ## 2. Corner Case\n> 코너 케이스는 여러 엣지 케이스가 동시에 발생하거나 더 극단적인 상황을 의미함\n> '코너(corner)'라는 이름은 여러 경계값이 만나는 지점, 즉 '모서리'에서 발생하는 케이스라는 의미에서 유래함\n> ### 1. 특징\n> - 여러 엣지 케이스의 조합으로 발생하는 더 복잡한 상황\n> - 매우 드물게 발생하지만, 발생 시 심각한 문제를 일으킬 수 있음\n> - 테스트하기 어려운 경우가 많음\n> ### 2. 예시\n> #### 1. 웹 애플리케이션: 네트워크 연결이 불안정한 상태에서 대용량 파일 업로드\n> #### 2. 모바일 앱: 배터리가 거의 없는 상태에서 GPS와 카메라를 동시에 사용\n> #### 3. 데이터베이스: 최대 연결 수에 도달한 상태에서 대량의 트랜잭션 처리\n> #### 4. 알고리즘: 정렬 알고리즘에서 이미 정렬된 역순 배열 처리\n> #### 5. UI: 매우 작은 화면에서 복잡한 대화상자 표시\n> ## 3. 두 개념의 차이점\n> ### 1. 범위와 복잡성\n> - 엣지 케이스: 단일 변수나 조건의 경계값\n> - 코너 케이스: 여러 변수나 조건의 경계값이 동시에 발생\n> ### 2. 발생 빈도\n> - 엣지 케이스: 상대적으로 더 자주 발생\n> - 코너 케이스: 매우 드물게 발생\n> ### 3. 예측 가능성\n> - 엣지 케이스: 비교적 예측하기 쉬움\n> - 코너 케이스: 예측하기 어려움\n> ## 4. 소프트웨어 개발에서의 중요성\n> ### 1. 견고한 시스템 구축: 엣지 케이스와 코너 케이스를 처리하면 더 안정적인 소프트웨어를 만들 수 있음\n> ### 2. 버그 예방: 이러한 케이스를 미리 고려하면 나중에 발생할 수 있는 심각한 오류를 예방할 수 있음\n> ### 3. 사용자 경험 향상: 예상치 못한 상황에서도 적절히 대응하여 사용자 만족도를 높일 수 있음\n> ### 4. 유지보수 비용 절감: 사후에 발견되는 버그를 수정하는 것보다 개발 단계에서 이러한 케이스를 고려하는 것이 비용 효율적임\n> \n> 엣지 케이스와 코너 케이스를 철저히 테스트하고 처리하는 것은 고품질 소프트웨어 개발의 핵심 요소\n> \n\n## 4. 일반적인 복잡도\n- O(1): 상수 시간 - 입력 크기와 관계없이 항상 동일한 작업 수행\n- O(log N): 로그 시간 - 이진 검색 등의 알고리즘\n- O(N): 선형 시간 - 입력 크기에 비례하여 증가\n- O(N log N): 퀵소트와 같은 정렬 알고리즘\n- O(N²): 제곱 시간 - 이중 반복문 등\n- O(N³): 세제곱 시간 - 행렬 곱셈 등\n- O(2^N), O(N!): 실용적이지 않은 알고리즘\n\n## 5. 복잡도 파악하는 법\n- 반복문을 찾기: 입력값에 대해 어떻게 반복하는지 확인하는 것이 가장 쉬운 방법\n- 예: 문자열의 길이만큼 반복하는 반복문은 O(N)\n- 중첩 반복문은 각 차원에 따라 복잡도가 증가 (예: 이중 반복문은 O(N²))\n\n## 6. 공간 복잡도\n- 시간 복잡도만큼 자주 논의되지는 않지만, 특정 상황에서는 중요할 수 있음\n- 알고리즘이 사용하는 메모리가 입력값에 따라 어떻게 증가하는지를 나타냄\n\n## 7. 퀵소트, 링 버퍼(실용적으로 유용함)"
  }
];
