// notes-data.js
// ⚠️  이 파일은 GitHub Actions가 자동 생성합니다. 직접 수정하지 마세요.
// Generated: auto by scripts/build_notes.py

var notesData = [
  {
    "slug": "3-sort",
    "title": "Core Data Structures &amp; Sorting Algorithms",
    "date": "2026-02-19",
    "category": "Algorithm",
    "tags": [
      "Bubble Sort",
      "Linked List",
      "Queue",
      "Stack",
      "Big O"
    ],
    "description": "A deep dive into Bubble Sort, Linked Lists, Queues, and Stacks — exploring how pointer manipulation enables O(1) operations, when linked lists outperform arrays, and how these foundational structures power real-world systems like video decoders and call stacks.",
    "content": "source: https://frontendmasters.com/courses/algorithms/bubble-sort/\n\n# 1. Bubble Sort\n## 1. 버블 정렬을 선택한 이유\n- 일반적인 알고리즘 책에서 삽입 정렬로 시작하는 것과 달리, 버블 정렬부터 설명하는 이유\n\t- 삽입 정렬의 문제점: 카드 덱 예제가 이해하기 어려움\n\t- 버블 정렬의 장점:\n\t\t1. 시각적으로 이해하기 매우 쉬움\n\t\t2. 단 3줄의 코드로 구현 가능\n\t\t3. 극도로 간단한 알고리즘\n\n## 2. 버블 정렬의 특징\n- 매우 간단한 정렬 알고리즘으로 구현이 쉬움\n- 제자리 정렬 (in-place sorting): 추가 메모리 공간을 거의 사용하지 않음\n- 이진 탐색보다도 구현이 간단함\n- 성능상의 한계\n\t- 불변 배열 (immutable array)에서 사용하면 성능이 매우 나빠짐\n\t- 역순으로 정렬된 배열의 경우 최악의 성능을 보임\n\t- 실제 개발에서는 거의 사용되지 않는 비효율적인 알고리즘\n\n## ​3. 정렬된 배열의 정의\n- 수학적으로 정렬된 배열의 정의:\n\t- 배열의 모든 i번째 위치에서 `x[i] ≤ x[i+1]`이 성립해야 함\n\t- 이 조건이 전체 배열에 대해 성립해야 정렬된 것\n\n## 4. 버블 정렬 알고리즘 동작 원리\n- 예시 배열: `[1, 3, 7, 4, 2]`\n- 핵심 원리:\n\t- 0번째 위치부터 시작해서 배열 끝까지 진행\n\t- 각 위치에서 다음 요소와 비교\n\t- 현재 요소가 다음 요소보다 크면 위치를 교환\n- 1회 반복 과정:\n\t1. 1과 3 비교 -> 교환 안함\n\t2. 3과 7 비교 -> 교환 안함\n\t3. 7과 4 비교 -> 7 > 4이므로 교환 -> `[1, 3, 4, 7, 2]`\n\t4. 7과 2 비교 -> 7 > 2이므로 교환 -> `[1, 3, 4, 2, 7]`\n- 결과: 1회 반복 후 가장 큰 값 (7)이 마지막 위치에 배치됨\n- 2회 반복 과정: 마지막 위치는 이미 정렬되었으므로 제외하고 진행\n- 3회 반복 과정: 뒤의 두 위치는 제외하고 진행\n- 이런 식으로 검사할 범위가 점점 줄어듦\n- 한 개 요소만 남을 때까지 반복 (한 개 요소는 항상 정렬된 상태)\n- 코드\n```typescript\nexport default function bubble_sort(arr: number[]): void {\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tfor (let j = 0; j < arr.length - 1 - i; j++) {\n\t\t\tif (arr[j] > arr[j + 1]) {\n\t\t\t\tconst temp = arr[j];\n\t\t\t\tarr[j] = arr[j + 1];\n\t\t\t\tarr[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n## 5. 시간 복잡도 분석\n- 반복 횟수:\n\t- 1회차: n번 비교\n\t- 2회차: n-1번 비교\n\t- 3회차: n-2번 비교\n\t- ...\n\t- 마지막: 1번 비교\n- 가우스의 일화를 통한 설명:\n\t- 1부터 100까지 더하는 문제를 가우스가 10초 만에 해결\n\t- 방법: 1+100=101, 2+99=101, ..., 50+51=101\n\t- 총 50개의 101 -> 101x50 = 5050\n\t- 일반화: `n(n+1)/2`\n- 시간 복잡도 계산:\n\t- 총 비교 횟수: `n + (n-1) + (n-2) + ... + 1 = n(n+1)/2`\n\t- 전개: `(n² + n)/2`\n\t- 상수 제거: n² + n\n\t- 최고차항만 고려: O(n²)\n- n이 커질수록 n²항이 지배적이 되어 n항은 무시할 수 있게 됨\n- 버블 정렬은 구현이 매우 간단하지만 O(n²)의 시간 복잡도를 가져 큰 데이터셋에는 비효율적인 알고리즘\n\n# 2. Linked List Data Structures\n## 1. 배열의 한계점\n### JavaScript 배열의 특성\n- JavaScript의 배열은 사실 진정한 배열이 아님\n- `push()`, 삽입, 삭제 등이 가능하고 인덱스가 자동으로 조절됨\n- 실제 배열 위에 추가적인 구조가 존재\n\n### 전통적인 배열의 문제점\n- 삭제: 실제로 삭제할 수 없고 0으로 만들 뿐\n- 삽입: 실제 삽입이 불가능\n- 크기 고정: 배열은 크기가 고정되어 있음\n\n## 2. 연결 리스트란?\n### 기본 개념\n- 첫 번째 진짜 자료구조로 간주\n- 노드 기반 자료구조 (Node-based data structure)\n- 연결 리스트에는 index가 없음\n- 각 노드는 데이터를 감싸는 컨테이너 역할\n\n### 노드 구조\n```typescript\ntype Node<T> = {\n\tvalue: T;       // 실제 데이터\n\tnext?: Node<T>;\n}\n```\n\n### 동작 원리\n- 각 노드가 값과 다음 노드에 대한 참조를 가짐\n- 체인처럼 연결된 구조\n- 헤드 (head)부터 시작해서 순차적으로 접근\n\n## 3. 단일 연결 리스트 vs 이중 연결 리스트\n### 단일 연결 리스트 (Singly Linked List)\n- 각 노드가 다음 노드만 참조\n- A -> B -> C -> D\n- 한 방향으로만 이동 가능\n- 뒤로 돌아갈 수 없음\n\n### 이중 연결 리스트 (Doubly Linked List)\n- 각 노드가 이전 노드와 다음 노드 모두 참조\n- A ⇄ B ⇄ C ⇄ D\n- 양방향 이동 가능\n- `previous`와 `next` 속성 보유\n\n## 4. 연결 리스트의 주요 연산\n### 삽입 (Insertion): O(1)\n- A와 B 사이에 F를 삽입하는 경우:\n\t1. A의 next를 F로 설정\n\t2. F의 next를 B로 설정\n\t3. B의 previous를 F로 설정\n\t4. F의 previous를 A로 설정\n- 시간 복잡도: O(1) - 상수 시간\n\n### 삭제 (Deletion): O(1)\n- C 노드를 삭제하는 경우( = C.prev & B.next = C.next):\n\t1. B의 next를 D로 설정 (C.next)\n\t2. D의 previous를 B로 설정 (C.previous)\n\t3. C의 next와 previous를 null로 설정 (C.prev = C.next = null)\n\t4. C의 값을 반환 (ret C.val)\n- 시간 복잡도: O(1) - 상수 시간\n\n## 5. 연결 리스트의 장점\n### 효율적인 삽입 / 삭제\n- 배열과 달리 요소를 이동시킬 필요 없음\n- 링크만 조정하면 되므로 O(1) 시간\n- 입력 크기와 무관하게 일정한 시간\n\n### 동적 크기\n- 필요에 따라 크기 조정 가능\n- 메모리를 효율적으로 사용\n\n## 6. 연결 리스트의 단점\n### 인덱스 접근 불가\n- 배열처럼 `arr[i]`로 직접 접근 불가\n- n번째 요소에 접근하려면 처음부터 순차적으로 이동해야 함\n- 접근 시간: O(n)\n\n### 메모리 오버헤드\n- 각 노드마다 포인터를 위한 추가 메모리 필요\n- 힙 (heap) 메모리 사용으로 스택보다 비용 증가\n\n## 7. 구현 시 주의사항\n### 연산 순서의 중요성\n- 링크를 끊기 전에 새로운 연결을 먼저 설정\n- 잘못된 순서로 하면 노드에 접근할 수 없게 됨\n\n### 경계 조건 처리\n- null 체크, undefined 체크 필요\n- 첫 번째나 마지막 노드 처리 시 특별한 주의\n\n## 8. 핵심 개념 정리\n- 연결 리스트는 메모리를 직접 할당하고 관리하는 첫 번째 자료구조로, 포인터를 통해 메모리를 순회하는 방식을 배울 수 있는 중요한 개념\n- 배열의 고정된 한계를 극복하고 동적인 자료 관리를 가능하게 해주는 핵심적인 자료구조\n\n\n> [!INFO]\n> # 연결 리스트의 삽입과 삭제의 시간 복잡도가 O(1)일 때의 중요한 전제 조건\n> ## 핵심 포인트: \"어디에\" 삽입 / 삭제 하는지가 중요함\n> ### 1. O(1)인 경우: 위치를 이미 알고 있을 때\n> \t기존: A -> B -> C -> D\n> \t\n> \tB와 C 사이에 X를 삽입하고 싶은데, 이미 B 노드의 참조 (포인터)를 가지고 있다면:\n> \t\n> \t1. X.next = B.next (X가 C를 가리키게)\n> \t2. B.next = X (B가 X를 가리키게)\n> \t\n> \tA -> B -> X -> C -> D\n> - 왜 O(1)인가?\n> \t- 포인터 2개만 바꾸면 끝\n> \t- 데이터를 이동시킬 필요 없음\n> \t- 노드를 찾아 헤매지 않음 (이미 위치를 알고 있으므로)\n> ### 2. O(n)인 경우: 위치를 찾아야 할 때\n> \t\"3번째 위치에 삽입해줘\"라고 하면:\n> \t\n> \t1. head부터 시작해서 1 -> 2 -> 3 순차 탑색 (O(n))\n> \t2. 찾은 후 삽입 (O(1))\n> \t3. 총 시간 복잡도: O(n)\n> \t\n> ### 3. 배열과의 비교\n> \t배열의 중간 삽입:\n> \t[A, B, C, D]에서 B 뒤에 X 삽입\n> \t\n> \t4. C와 D를 한 칸씩 뒤로 밀어야 함\n> \t5. [A, B, _ , C, D] -> [A, B, X, C, D]\n> \t6. 시간 복잡도: O(n) (데이터 이동 때문에)\n> \t\n> \t연결 리스트의 삽입 (위치를 안다면):\n> \t포인터만 바꾸면 끝 -> O(1)\n> \t\n> ### 실제로는 ...\n> \t대부분의 경우 \"어디에 삽입할지\" 먼저 찾아야 하므로:\n> \t- 찾기: O(n)\n> \t- 삽입: O(1)\n> \t- 전체: O(n)\n> \t하지만 head나 tail에 삽입하거나, 이미 노드 찹조를 가지고 있는 경우에는 O(1)\n\n\n# 3. Linked List Complexity\n## 1. 기본 연산들\n- 만약 다섯 번째 값을 요청한다면, 이런 구조에서는 다섯 번째 값을 바로 가져올 방법이 없음\n- 문자 그대로 0부터 5까지의 루프를 작성해야 하고, `current = current.next`와 같은 방식으로 올바른 값에 도달할 때까지 순회해야 함\n- 중요한 점\n\t- 포함하는 노드 (containing node) 자체를 반환해서는 안 됨\n\t- 그럴 경우, 내부 구조가 노출되어 누군가에게 next와 previous 값을 조작할 수 있고, 그러면 전체 리스트가 망가짐\n\t- 이는 실용적인 구현 관점에서 중요함\n\t- 포함하는 노드는 우리는 위한 추상화일 뿐, 외부 세계를 위한 것이 아님\n\n## 2. 시간 복잡도 분석\n### 헤드 (Head)와 테일 (Tail) 접근\n- 헤드와 테일 가져오기: 상수 시간 (O(1)) 연산\n- 연결 리스트 구현이 첫 번째 항목을 가리키는 단일 참조 (head)를 가지고 있다면, 리스트의 크기에 관계없이 헤드 가져오기는 상수 연산이 됨\n- 테일에 대해서도 이미 정의된 포인터가 있기 때문에 상수 연산이 가능함\n\n### 삭제 (Deletion) 연산\n- 앞이나 뒤에서의 삭제: 상수 시간 연산\n- 삭제 알고리즘만 적용하면 됨\n- 중간에서의 삭제: 해당 지점까지 순회해야 하므로 비용이 큼\n- 두 가지 연산 비용이 있음: 순회 + 삭제\n- 양 끝에서의 삭제는 상수 시간이지만, 중간에서의 삭제는 순회가 비싸면 비용이 큼\n- 삭제 자체는 비용이 크지 않음\n\n### 삽입 (Insertion) 연산\n- 앞에 추가 (Prepending)와 뒤에 추가 (Appending): 상수 시간\n- head나 tail에서 링크만 끊으면 되므로 매우 빠름\n- 중간 삽입: 다시 순회가 문제\n- 빠르게 순회할 수 있다면 삽입도 빠름\n\n## 3. 연결 리스트의 장단점\n### 장점\n- 원하는 크기로 만들 수 있음\n- 앞이나 뒤에서의 삭제가 극도로 빠름\n- 이 장점이 매우 중요함. 많은 구조에서 \"가장 오래된 항목을 삭제\"하고 싶을 때가 있는데, 가장 오래된 항목이 테일에 정리되어 있으면 상수 연산으로 매우 빠르게 처리 가능\n\n### 단점\n- 좀 더 복잡함\n- 연속적인 메모리가 아님\n- 연속적인 메모리에 대한 컴퓨터 최적화들이 있지만, 중요한 것은 이런 것들을 저장할 수 있다는 점임\n\n## 4. 연결 리스트의 중요성\n- 모든 연결 리스트는 그래프\n- 모든 연결 리스트는 기술적으로 트리\n- 연결 리스트는 가장 기본적인 단위로써, 연결 리스트에서 순회하고 움직이는 방법을 이해한다면, 다른 모든 데이터 구조들을 이해할 수 있음 (다른 복잡한 데이터 구조들 (그래프, 트리)의 기반이 됨)\n\n# 4. Queue\n## 1. 자료구조 vs 알고리즘의 구분\n- 자료구조와 알고리즘의 구분이 모호할 수 있음\n- 연결 리스트의 경우, 실제 구조 자체는 자료구조이지만, 삽입 과정은 알고리즘적 측면이 있음\n\n## 2. Queue의 정의와 특징\n- 큐는 연결 리스트 위에 구현된 특별한 자료구조\n- FIFO (First In First Out) 구조\n- 영국에서는 \"queue\"라고 부르고, 미국에서는 \"line\"이라고 부름 (줄서기와 같은 개념)\n\n## 3. Queue의 구현 방식\n### 기본 구조\n- Head: 큐의 앞쪽 (데이터가 나가는 곳)\n- Tail: 큐의 뒤쪽 (데이터가 들어가는 곳)\n- 단일 연결 리스트로 충분함 (이중 연결 리스트 불필요)\n### 삽입 (Enqueue) 연산\n```typescript\nthis.tail.next = newNode;\nthis.tail = newNode;\n```\n- 새로운 요소를 꼬리 (tail) 뒤에 추가\n- 꼬리 포인터를 새로운 노드로 업데이트\n### 제거 (Dequeue) 연산\n```typescript\nconst oldHead = head;\nhead = head.next;  // head를 A -> B로 이동\noldHead.next = null;  // A를 없애줌\nreturn oldHead.value;\n```\n- 머리 (head)에서 요소를 제거\n- 머리 포인터를 다음 노드로 이동\n- 제거된 노드의 값을 반환\n### Peek 연산\n```typescript\nreturn head.value;\n```\n- 큐의 첫 번째 요소를 제거하지 않고 확인\n\n> [!INFO]\n> # PEEK 연산의 개념\n>  - Peek 연산은 자료구조에서 매우 중요한 개념으로, \"엿보기\" 또는 \"미리 보기\"라는 의미\n> ## 1. 기본 정의\n>  - Peek은 자료구조의 다음에 처리될 요소를 제거하지 않고 단순히 확인만 하는 연산\n>  - 큐에서의 Peek\n>  ```typescript\n>  // 큐에서 peek 연산\n>  peek(): T {\n> \t return this.head.value;  // 제거하지 않고 값만 반환\n>  }\n>  ```\n>\n>  - 큐의 맨 앞 (head)에 있는 요소를 확인\n>  - 요소를 제거하지 않음\n>  - 큐의 상태는 그대로 유지\n> ## 2. Peek vs Dequeue 비교\n> <img width=\"677\" height=\"100\" alt=\"image\" src=\"https://github.com/user-attachments/assets/708d2602-6bc8-41b4-8b54-3b1bfc127ee1\"/>\n>\n> ## 3. 성능 특성\n>  - 시간 복잡도: O(1) - 상수 시간\n>  - 공간 복잡도: O(1) - 추가 메모리 사용 없음\n> ## 4. 핵심 포인트\n>  - Peek 연산의 가장 중요한 특징은 \"Look but don't touch\" 원칙\n>  - 즉, 데이터를 확인은 하지만 자료구조의 상태를 변경하지 않아서, 나중에 다시 같은 요소에 접근할 수 있음\n>  - 이는 조건부 처리나 미리 확인이 필요한 알고리즘에서 매우 유용함\n\n## 4. 성능 특성\n- 삽입 (Enqueue): O(1) - 상수 시간\n- 제거 (Dequeue): O(1) - 상수 시간\n- Peek: O(1) - 상수 시간\n- 모든 연산이 리스트를 순회하지 않고 포인터만 조작하므로 매우 효율적임\n\n## 5. 실용적 활용 사례\n- 비디오 디코더에서 비디오 데이터를 올바른 순서로 버퍼링하기 위해 큐를 사용할 수 있음\n- 비디오 디코더에서 큐를 사용하는 이유\n\t- 순서가 중요한 데이터를 처리할 때\n\t- 들어온 순서대로 처리해야 할 때\n\t- 실시간성이 중요할 때\n\t- 효율적인 버퍼링이 필요할 때\n- 비디오는 시간 순서가 절대적으로 중요한 데이터이기 때문에, FIFO 방식의 큐가 가장 적합한 자료구조\n\n## 6. 핵심 개념\n- 큐는 제약을 가함으로써 성능을 최적화한 자료구조\n- 일반적인 연결 리스트의 기능을 제한하여 특정 용도 (FIFO)에 최적화된 매우 빠른 자료구조를 만든 것\n\n## 7. Implementing a Queue\n### Queue의 기본 개념\n- Queue는 FIFO 방식으로 동작하는 자료구조\n- Queue가 비교적 간단한 자료구조이며, 하나의 링크만 관리하면 되므로 구현이 어렵지 않음\n- 주요 메서드: enqueue (추가), dequeue (제거), peek (조회)\n\n### 구현 단계\n1. 기본 타입 정의\n```typescript\ntype QueueNode<T> = {\n\tvalue: T;\n\tnext?: QueueNode<T>;\n}\n\nclass Queue<T> {\n\tprivate head?: QueueNode<T>;\n\tprivate tail?: QueueNode<T>;\n\tpublic length: number;\n}\n```\n\n2. 생성자\n```typescript\nconstructor() {\nthis.head = this.tail = undefined;\nthis.length = 0;\n}\n```\n\n3. peek() 메서드\n- 큐의 맨 앞 요소를 반환 (제거하지 않음)\n- `return this.head?.value;` 형태로 구현\n\n4. dequeue() 메서드 (제거)\n- 큐의 맨 앞 요소를 제거하고 반환\n- head가 없으면 undefined 반환\n- head를 다음 노드로 업데이트\n- length 감소\n\n5. enqueue() 메서드 (추가)\n- 큐의 맨 뒤에 새 요소 추가\n- 두 가지 경우 처리:\n\t- 빈 큐의 경우: head와 tail을 새 노드로 설정\n\t- 기존 요소가 있는 경우: tail의 next를 새 노드로 연결하고 tail 업데이트\n\n### 핵심 포인트\n#### 메모리 관리\n- JavaScript의 가비지 컬렉터 덕분에 수동 메모리 해제가 불필요\n- 다른 언어에서는 free() 같은 메모리 해제 작업이 필요\n\n#### 제네릭 확용\n- `<T>` 제네릭을 사용하여 어떤 타입의 데이터든 저장 가능\n- 타입 안전성 보장\n\n#### 연결 리스트 구조\n- 각 노드가 다음 노드를 가리키는 단방향 연결 리스트\n- head와 tail 포인터로 효율적인 삽입 / 삭제 가능\n\n### 코드\n```typescript\ntype Node<T> = {\n\tvalue: T;\n\tnext?: Node<T>,\n}\n\nexport default class Queue<T> {\n\tpublic length: number;\n\tprivate head?: Node<T>;\n\tprivate tail?: Node<T>;\n\n\tconstructor() {\n\t\tthis.head = this.tail = undefined;\n\t\tthis.length = 0;\n\t}\n\t\n\tenqueue(item: T): void {\n\t\tconst node = {value: item} as Node<T>;\n\t\tthis.length++;\n\t\tif (!this.tail) {\n\t\t\tthis.tail = this.head = node;\n\t\t\treturn;\n\t\t}\n\t\tthis.tail.next = node;\n\t\tthis.tail = node;\n\t}\n\n\tdeque(): T | undefined {\n\t\tif (!this.head) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis.length--;\n\n\t\tconst head = this.head;\n\t\tthis.head = this.head.next;\n\n\t\t// free\n\t\thead.next = undefined;\n\n\t\t// 큐가 비어있을 때 tail을 undefined로 설정\n\t\tif (this.length === 0) {\n\t\t\tthis.tail = undefined;\n\t\t}\n\n\t\treturn head.value;\n\t}\n\n\tpeek(): T | undefined {\n\t\treturn this.head?.value;\n\t}\n}\n```\n- 큐의 dequeue 연산 구현\n\t- 큐에서 요소를 제거 (dequeue)할 때 typescript 에러가 발생\n\t- `this.length`가 0이 되면 `tail`도 `undefined`로 설정해야 함\n```typescript\nif (this.length === 0) {\n\tthis.tail = undeifned;\n}\n```\n- peek 메서드 구현\n```typescript\npeek() {\n\treturn this.head ? this.head.value : undefined;\n}\n```\n\n# 5. Stack\n## 1. 스택의 기본 개념\n- 스택은 연결 리스트를 기반으로 한 자료구조로 다음과 같은 특징을 가짐\n\t- 노드는 값 (value)과 다음 노드를 가리키는 포인터 (next)를 포함\n\t- 이중 연결 리스트의 경우 이전 노드를 가리키는 포인터 (previous)도 포함\n\n## 2. 스택 vs 큐의 차이점\n- Queue: A -> B -> C -> D 순서로, head와 tail이 있음\n- Stack: Queue와 반대 반향으로 작동\n\t- A -> B -> C -> D에서 head가 맨 앞에 위치\n\t- 한쪽 끝 (head)에서만 추가와 제거가 이루어짐\n\n## 3. 스택의 시각적 이해\n- 스택을 \"접시 더미\"라고 생각\n\t- 접시를 쌓을 때는 맨 위에 올리고\n\t- 접시를 꺼낼 때도 맨 위에서 꺼냄\n\t- LIFO (Last In, First Out) 원리\n\n## 4. Stack의 주요 연산\n### 1. Push (추가) 연산\n```\nE를 추가할 때:\n1. E가 현재 head를 가리키도록 함\n2. head를 E로 업데이트\n```\n\n### 2. Pop (제거) 연산\n```\n1. 현재 head를 임시 저장\n2. head를 다음 노드로 업데이트\n3. 제거된 노드 반환\n```\n\n### 3. Peek 연산\n- 큐와 동일하게 head의 값을 반환 (제거하지 않음)\n\n## 5. 스택의 실제 활용\n1. 함수 호출: 함수를 호출할 때 스택 구조로 관리됨\n2. 스택 트레이스: 코드 에러 시 함수 호출 순서를 보여주는 것\n3. 메모리 관리: 컴퓨터의 메모리 영역 중 \"스택\"이라 불리는 부분\n\n## 6. 시간 복잡도\n- 모든 스택 연산 (push, pop, peek)은 O(1) 상수 시간\n\t- 포인터만 업데이트하면 되므로\n\t- 리스트의 크기나 값의 크기와 무관하게 동일한 시간 소요\n\n## 7. 주의사항\n- 스택과 큐를 구현할 때 연산 순서를 잘못하면 데이터를 잃어버릴 수 있음\n- 특히 메모리 관리가 중요한 언어에서는 메모리 누수가 발생할 수 있음"
  },
  {
    "slug": "2-search",
    "title": "Search Algorithms 101",
    "date": "2026-02-18",
    "category": "Algorithm",
    "tags": [
      "Linear Search",
      "Binary Search",
      "Two Crystal Balls Problem",
      "Greedy Algorithm"
    ],
    "description": "Covers linear search, binary search, and the Two Crystal Balls problem, along with an introduction to greedy algorithms. Includes pseudocode, implementation details, and complexity analysis for each approach.",
    "content": "source: https://frontendmasters.com/courses/algorithms/binary-search-algorithm/\n\n# 1. Linear Search\n## 1. 기본 개념\n- 선형 검색은 가장 기본적인 검색 알고리즘\n- 배열이나 리스트의 처음부터 끝까지 순차적으로 모든 요소를 확인하면서 원하는 값을 찾는 방식\n\n## 2. 특징\n- 구현이 매우 간단함\n- 정렬되지 않은 데이터에서도 사용 가능\n- 시간 복잡도: O(n) -> 최악의 경우 모든 요소를 확인해야 함\n- 공간 복잡도: O(1) -> 추가 메모리가 거의 필요 없음\n\n## 3. 동작 과정\n### 1. 배열의 첫 번째 요소부터 시작\n### 2. 현재 요소가 찾는 값인지 확인\n### 3. 맞다면 해당 위치 반환, 아니면 다음 요소로 이동\n### 4. 배열 끝까지 반복하며 값을 찾지 못하면 \"찾을 수 없음\" 반환\n\n\n# 2. Binary Search\n## 1. 기본 개념\n- 이진 검색은 정렬된 배열에서 사용할 수 있는 효율적인 검색 알고리즘\n- 중간 요소를 확인하고 찾는 값이 중간값보다 작은지 큰지에 따라 검색 범위를 절반으로 줄여나가는 방식\n\n## 2. 특징\n- 정렬된 데이터에서만 사용 가능\n- 선형 검색보다 훨씬 빠름\n- 시간 복잡도: O(log n) -> 매 단계마다 검색 범위가 절반으로 줄어듦\n- 공간 복잡도: 반복적 구현 시 O(1), 재귀적 구현 시 O(log n)\n\n## 3. 동작 과정\n### 1. 배열의 중간 요소를 확인\n### 2. 중간 요소가 찾는 값과 일치하면 해당 위치 반환\n### 3. 찾는 값이 중간 요소보다 작으면 왼쪽 절반에서 검색 계속\n### 4. 찾는 값이 중간 요소보다 크면 오른쪽 절반에서 검색 계속\n### 5. 범위가 더 이상 없을 때까지 반복하고, 찾지 못하면 \"찾을 수 없음\" 반환\n\n> [!INFO]\n> # 두 알고리즘의 비교\n> 예를 들어, 100만 개의 요소가 있는 배열에서 선형 검색은 최악의 경우 100만 번의 비교가 필요하지만, 이진 검색은 최대 약 20번의 비교만으로 찾을 수 있음\n> \n> <img width=\"627\" height=\"178\" alt=\"image\" src=\"https://github.com/user-attachments/assets/ab27def9-21c1-4ee6-85a9-d7b4e04999d6\" />\n\n\n## 4. 알고리즘 구현 방법\n### 1. 주요 변수\n- `lo`: 탐색 시작 지점 (포함)\n- `hi`: 탐색 끝 지점 (미포함)\n- `mid`: 중간 지점 인덱스\n- `array`: 탐색할 정렬된 배열\n- `needle`: 찾고자 하는 값\n\n### 2. 의사코드 (Pseudocode)\n```\nfunction search(array, lo, hi, needle):\n\tdo:\n\t\tmid = lo + (hi - lo) / 2     // 중간 지점 계산\n\t\tvalue = array[mid].          // 중간 지점의 값 가져오기\n\n\t\tif value == needle:          // 값을 찾았을 경우\n\t\t\treturn true (또는 mid)\n\t\telse if value < needle:      // 찾는 값이 중간값보다 클 경우\n\t\t\tlo = mid + 1             // 오른쪽 부분 배열 탐색\n\t\telse:\n\t\t\thi = mid                 // 왼쪽 부분 배열 탐색\n\t\twhile lo < hi                // 탐색 범위가 유효할 때까지 반복\n\n\t\treturn false (또는 -1)        // 값을 찾지 못했을 경우\n```\n\n### 3. 중요 포인트\n#### 1. 항상 정렬된 배열에서만 사용해야 함\n#### 2. `lo`는 포함 (inclusive), `hi`는 미포함 (exclusive)으로 처리함\n#### 3. 종료 조건은 `lo < hi`가 아닐 때임 (탐색 범위가 없어질 때)\n#### 4. 값을 찾지 못했을 경우, -1이나 false를 반환하는데, 이를 '센티넬 (sentinel) 값'이라고 부름\n\n\n> [!INFO]\n> # sentinel 값\n> ## 사용 목적\n> ### 1. 데이터 종료 표시\n> - 데이터 스트림이나 배열, 리스트 등의 끝을 나타내기 위해 사용됨\n> - 예: c언어에서 문자열의 끝을 나타내는 널 (NULL) 문자 ('\\0')가 대표적인 센티넬 값\n> ### 2. 특별한 상태 표시\n> - 특정 함수나 알고리즘에서 특별한 상태나 조건을 나타내기 위해 사용됨\n> - 일반적인 데이터 값과는 구분되는 특수한 값을 사용함\n> ### 3. 오류 상태 표시\n> - 함수가 실패했거나 비정상적인 상황이 발생했음을 나타내기 위해 사용됨\n> - 예: 많은 함수에서 -1이나 NULL을 반환하여 오류를 표시함\n>\n> - 센티넬 값은 일반적으로 해당 데이터 타입에서 실제 데이터로는 거의 사용되지 않을 값을 선택함\n> - 이는 일반 데이터와 센티넬 값 사이의 충돌을 방지하기 위함\n> - 예:\n> \t- 정수형 데이터에서 -1이나 최대값 (MAX_INT) 등을 센티넬 값으로 사용\n> \t- 포인터에서는 NULL을 센티넬 값으로 사용\n> \t- 문자열에서 특수 문자를 센티넬 값으로 사용\n> - 센티넬 값은 알고리즘의 흐름을 제어하거나 특별한 케이스를 표시하는 데 매우 유용한 프로그래밍 기법\n\n## 5. 이진 검색 구현\n### 1. 기본 설정\n- 함수는 'haystack (배열)'과 'needle (찾고자 하는 값)'을 매개변수로 받음\n- 반복문으로 do-while 루프 사용 (다른 반복문도 사용 가능)\n- 초기 변수 설정: lo=0 (시작점), \bhi=haystack.length (끝점)\n\n### 2. 핵심 로직\n- 중간점 (midpoint) 계산: `const m = Math.floor((lo + hi - l) / 2)`\n  - warning! 2로 나누는 것을 잊지 말 것!\n- 현재 중간값 가져오기: `const value = haystack[m]`\n- 반복 조건: `while (lo < hi)`\n\n### 3. 검색 조건 처리\n- 중간값이 찾는 값과 같은 때: `value === needle`이면 `return true`로 찾았음을 반환\n- 중간값이 찾는 값보다 클 때: `value > needle`이면 오른쪽 부분은 모두 큰 값이므로 `hi = m`으로 검색 범위 축소\n- 중간값이 찾은 값보다 작을 때: 그 외의 경우 (else)에는 `lo = m + 1`로 왼쪽 부분 제외\n\n> [!IMPORTANT]\n> # `lo = m + 1`인 이유\n> ## 1. 현재 중간값 `m`은 이미 확인했음: `value < needle`이므로 `m` 위치의 값은 우리가 찾는 값이 아님\n> ## 2. 중간값보다 작은 모든 값들도 제외: 배열이 정렬되어 있으므로, `m`보다 왼쪽에 있는 모든 값들 (`lo`부터 `m`까지)은 우리가 찾는 값보다 작음\n> ## 3. lo는 inclusive이므로: 다음 검색 범위에서 `m+1`부터 시작해야 함\n> - 만약 `lo = m`으로 설정하면, 다음 반복에서 또 같은 `m` 값을 확인하게 되어 무한루프 위험\n> \n> 예:\n> ```\n> 배열: [1, 3, 5, 7, 9], needle = 7\n> lo = 0, hi = 5, m = 2, value = 5\n> 5 < 7이므로 오른쪽 절반을 검색해야 함\n> lo = m + 1 = 3 (인덱스 3부터 시작 = 값 7부터)\n> ```\n> \n> 반대로 `hi = m`에서는 +1을 하지 않는 이유:\n> - hi는 exclusive이므로 `m`을 포함하지 않음\n> - 이미 `m`을 제외한 범위가 됨\n> \n> 위의 내용이 이진 검색에서 흔히 발생하는 \"off-by-one error\"를 피하는 핵심\n\n> [!INFO]\n> # Off-by-one error\n> - 프로그래밍에서 가장 흔한 실수 중 하나로, 인덱스나 카운터를 1만큼 잘못 계산하는 오류\n> - 정확하게 처리하지 않으면 무한루프나 잘못된 결과를 만들어내는 까다로운 버그\n> \n> ## 1. 배열 인덱스 실수\n> ```javascript\n> // 잘못된 예: off-by-one error\n> const arr = [1, 2, 3, 4, 5];\n> for (let i = 1; i <= arr.length; i++) { // 1부터 시작, <= 사용\n> \tconsole.log(arr[i]); // 2, 3, 4, 5, undefined (마지막에 오류)\n> }\n> \n> // 올바른 예\n> for (let i = 0; i < arr.length; i++) { // 0부터 시작, < 사용\n> \tconsole.log(arr[i]); // 1, 2, 3, 4, 5\n> }\n> ```\n> \n> ## 2. 이진 검색에서의 off-by-one error\n> ```javascript\n> // 문제가 될 수 있는 경우들\n> lo = m;                      // m을 다시 포함시켜 무한루프 위험\n> hi = m + 1;                // 경계를 잘못 설정\n> ```\n> \n> ## 3. 일상적인 예시들\n> - 문자열 길이: \"Hello\"의 길이는 5이지만, 마지막 문자의 인덱스는 4\n> - 반복문 범위: 10번 반복하려면 `i < 10`이어야 하는데, `i <= 10`으로 써서 11번 반복\n> - 날짜 계산: 1월 1일부터 1월 5일까지는 5일이 아니라 4일 차이\n> \n> ## 4. 왜 이진 검색에서 중요한가?\n> ```javascript\n> // 만약 lo = m으로 했다면\n> lo = 0, hi = 2, m = 1\n> lo = m = 1           // 다음에 또 m = 1이 나올 수 있음 -> 무한루프\n> \n> // lo = m + 1로 하면\n> lo = m + 1 = 2     // 확실히 범위가 줄어듦\n> ```\n\n### 4. 코드\n```javascript\n// haystack: number[]\n// needle: number\n\nlet lo = 0;\nlet hi = haystack.length - 1;\n\nwhile (lo <= hi) {\n\tlet m = Math.floor((lo + hi) / 2);\n\n\tif (needle === haystack[m]) {\n\t\treturn true;\n\t}\n\telse if (needle < haystack[m]) {\n\t\thi = m - 1;\n\t}\n\telse {\n\t\tlo = m + 1;\n\t}\n\treturn false;\n}\n```\n\n# 3. Two Crystal Balls Problem\n## 1. 문제 설명\n- 특정 높이에서 떨어뜨리면 깨지는 두 개의 수정구슬\n- 이 구슬들이 정확히 어느 지점에서 깨지는지를 가장 효율적인 방법으로 찾아야 함\n- 예: 100층 건물에서 몇 층부터 구슬이 깨지는지 찾는 문제\n\n## 2. 문제의 본질 (일반화)\n- 거짓 (false)들로 가득한 배열이 있고\n- 어느 지점부터는 참 (true)이 되어 계속 참을 유지\n- 이 전환점을 찾는 것이 목표\n\n## 3. 기존 접근법들의 한계\n### 1. 선형 탐색 (Linear Search)\n- 처음부터 하나씩 확인\n- 시간복잡도: O(N)\n- 두 번째 구슬을 전혀 활용하지 못함\n\n### 2. 이진 탐색 (Binary Search)\n- 중간 지점부터 시작\n- 만약 중간에서 깨진다면? -> 구슬 하나 소모\n- 나머지 구슬로는 처음부터 선형 탐색 해야 함\n- 결국 최악의 경우 O(N)\n\n## 4. 최적해: √N 접근법\n- 제곱근 단위로 점프하기\n\n### 1. 알고리즘 과정\n#### 1. √N만큼 점프하면서 첫 번째 구슬로 테스트\n#### 2. 구슬이 깨질 때까지 계속 점프\n#### 3. 깨지면 마지막으로 안전했던 지점으로 돌아가기\n#### 4. 두 번재 구슬로 선형적으로 탐색 (최대 √N 거리)\n\n### 2. 시간복잡도 분석\n- 점프 횟수: 최대 √N번\n- 선형 탐색: 최대 √N번\n- 총 시간복잡도: √N + √N = 2√N = O(√N)\n\n### 3. 핵심 아이디어\n- 기존 이진 탐색이 N/2 단위로 점프하여 문제가 생겼다면, √N 단위로 점프함으로써 두 구슬을 모두 효과적으로 활용할 수 있게 됨\n- 이는 선형 탐색 O(N)보다 훨씬 효율적이면서도, 제약 조건 (구슬 2개)을 잘 활용한 창의적인 해결책\n\n\n> [!QUESTION]\n> # 수정구슬이 하나만 있어도 같은 알고리즘이 작동하지 않을까?\n> ## 1. 수정구슬이 하나만 있을 때의 문제점\n> - 수정구슬이 하나뿐이라면, 유일한 방법은 선형 탐색 (Linear Search)\n> - 1층부터 차례대로 올라가면서 테스트\n> - 구슬이 깨질 때까지 한 층씩 확인\n> - 시간복잡도: O(N) -> 매우 비효율적\n> ## 2. 왜 √N 알고리즘에는 두 개가 필요한가?\n> - √N 알고리즘이 작동하는 핵심은 두 단계 과정\n> ### 1. 1단계: 첫 번째 구슬로 √N씩 점프\n> - √N 간격으로 큰 점프를 하며 테스트\n> - 구슬이 깨질 때까지 여러 층을 건너뛰기\n> ### 2. 2단계: 두 번째 구슬로 정확한 지점 찾기\n> - 첫 번째 구슬이 깨진 후\n> - 마지막 안전한 층으로 돌아가서\n> - 두 번째 구슬로 선형 탐색 (최대 √N 범위)\n>\n> ## 3. 핵심 포인트\n> - √N만큼 점프한다는 것은 특정 수의 층을 건너뛴다 (skipping)는 의미\n> - 수정구슬 중 하나가 깨지면, 목표 층이 마지막 '안전한' 층과 현재 층 사이 어딘가에 있다는 것을 알 수 있음\n> - 그래서 그 안전한 층부터 선형 탐색을 통해 목표 층을 찾는 것\n> ## 4. 결론\n> - 구슬 1개: 처음부터 끝까지 선형 탐색만 가능 -> O(N)\n> - 구슬 2개: 점프 + 정밀 탐색의 조합 가능 -> O(√N)\n> - 두 번째 구슬이 있기 때문에 실험적으로 큰 점프를 시도할 수 있고, 실패해도 다시 정밀하게 찾기가 가능한 것임\n\n## 5. Crystal Ball Problem 알고리즘 구현\n### 1. 문제 개요\n- 높은 건물에서 수정구를 떨어뜨릴 때, 어느 층부터 깨지는지 찾는 문제\n- 배열로 표현: `[false, false, false, true, true, ture]` (false=안 깨짐, true=깨짐)\n- 목표: 수정구가 처음으로 깨지는 층 (인덱스)을 찾기\n\n### 2. 왜 이진 탐색이 안 되는가?\n- 이진 탐색으로 중간 지점에서 수정구를 떨어뜨렸는데 깨졌다면?\n- 남은 수정구가 1개 뿐이므로, 처음부터 그 지점까지 선형적으로 하나씩 확인해야 함\n- 결국 최악의 경우 N/2만큼 확인해야 하므로 여전히 선형 시간\n\n### 3. 해결책: √N 점프 알고리즘\n#### 1. 핵심 아이디어\n##### 1. 첫 번째 수정구: √N만큼 점프하면서 깨지는 지점 찾기\n##### 2. 두 번째 수정구: 깨진 지점에서 √N만큼 뒤로 돌아가서 선형 탐색\n\n#### 2. 알고리즘 단계 (코드)\n```javascript\nexport default function two_crystal_balls(breaks: boolean[]): number {\n\t// breaks 배열의 의미\n\t// breaks[i] = true: i층에서 크리스탈 볼이 깨짐\n\t// breaks[i] = false: i층에서 크리스탈 볼이 안전함\n\n\tconst jmpAmount = Math.floor(Math.sqrt(breaks.length));\n\n\tlet i = jmpAmount;\n\tfor (; i < breaks.length; i += jmpAmount) {\n\t\tif (breaks[i]) { // breaks[i]가 true라면 (= if (breaks[i] === true))\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ti -= jmpAmount; // 마지막으로 안전했던 층으로 돌아감\n\n\t// 안전했던 층부터 시작해서 한 층씩 올라가며 탐색\n\tfor (let j = 0; j <- jmpAmount && i < breaks.length; ++j, ++i) {\n\t\tif (breaks[i]) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n```\n\n### 4. 시간 복잡도 분석\n#### 1. 최악의 경우\n##### 1. 첫 번째 단계: √N번 점프\n##### 2. 두 번째 단계: √N번 선형 탐색\n##### 3. 총 시간 복잡도: O(√N + √N) = O(√N)\n\n#### 2. 왜 √N이 최적인가?\n- √N보다 작게 점프하면: 점프 횟수가 증가\n- √N보다 크게 점프하면: 선형 탐색 구간이 증가\n- √N이 두 구간의 균형점\n\n### 5. 다른 루트 값들과의 비교\n- 세제곱근(∛N): 점프 거리는 줄어들지만 점프 횟수가 증가하여 비효율적\n- 네제곱근이나 더 높은 루트: 선형 탐색에 가까워져서 비효율적\n- √N이 최적의 균형점\n\n### 6. 핵심 포인트\n#### 1. 이진 탐색은 수정구 문제에서 선형 시간이 됨\n#### 2. √N 점프로 O(√N) 시간 복잡도 달성\n#### 3. 첫 번째 수정구로 대략적 위치 파악, 두 번째로 정확한 위치 찾기\n#### 4. √N이 점프 거리와 선형 탐색 거리의 최적 균형점\n\n\n> [!INFO]\n> # 탐욕적 접근법 (Greedy Algorithm)\n> - 매 순간 가장 좋아 보이는 선택을 하는 알고리즘 설계 기법\n> ## 1. 탐욕적 접근법의 특징\n> ### 1. 핵심 원리\n> - 현재 상황에서 최선의 선택을 함\n> - 미래의 결과를 고려하지 않음\n> - 지역적 최적해 (local optimum)를 선택해서 전역적 최적해 (global optimum)를 찾으려 함\n> ### 2. 일반적인 절차\n> #### 1. 선택: 현재 상황에서 최선의 선택을 한다\n> #### 2. 적용: 선택한 것을 현재 해에 추가한다\n> #### 3. 확인: 문제가 해결되었는지 확인한다\n> #### 4. 반복: 해결되지 않았다면 1단계로 돌아간다\n> \t\n> ## 2. 대표적인 예시들\n> ### 거스름돈 문제\n> ```typescript\n> // 730원을 거슬러 줄 때 (동전: 500원, 100원, 50원, 10원)\n> function makeChange (amount: number): number[] {\n> \tconst coin = [500, 100, 50, 10];\n> \tconst result = [];\n> \tamount = 730;\n> \t\n> \tfor (const coin of coins) {\n> \t\twhile (amount >= coin) {\n> \t\t\tresult.push(coin); // 사용한 동전을 배열의 끝에 추가\n> \t\t\tamount -= coin; // 탐욕적 선택: 가장 큰 동전부터\n> \t\t}\n> \t}\n> \treturn result; // [500, 100, 100, 10, 10, 10]\n> }\n> ```\n> ### 활동 선택 문제\n> #### 1. 시각적 표현\n> 시간:  0   1   2   3   4   5   6   7   8   9\n> 활동A:        [----A----]\n> 활동B:             [--B--]                        (A와 겹침 - 제외)\n> 활동C:   [--------C--------]             (A,D와 겹침 - 제외)\n> 활동D:                        [--D--]             (선택)\n> 활동E:                                   [E]          (선택)\n> 활동F:                         [----F----]      (D,E와 겹침 - 제외)\n> 선택됨:        [----A----]  [--D--]  [E]\n> #### 2. 문제 상황\n> - 한 개의 강의실이 있고, 여러 활동들이 각각 시작 시간과 끝나는 시간을 가지고 있음\n> - 겹치지 않으면서 최대한 많은 활동을 선택해야 함\n> #### 3. 구체적인 예시\n> ```typescript\n> const activities = [\n> \t{ name: 'A', start: 1, end: 4 }, // 1시~4시 \n> \t{ name: 'B', start: 3, end: 5 }, // 3시~5시 \n> \t{ name: 'C', start: 0, end: 6 }, // 0시~6시 \n> \t{ name: 'D', start: 5, end: 7 }, // 5시~7시 \n> \t{ name: 'E', start: 8, end: 9 }, // 8시~9시 \n> \t{ name: 'F', start: 5, end: 9 } // 5시~9시\n> ];\n> ```\n> #### 4. 알고리즘 단계별 실행\n> ##### 1. 끝나는 시간 순으로 정렬\n> ```typescript\n> activities.sort((a, b) => a.end - b.end);\n> ```\n>\n> 정렬 후:\n> ```typescript\n> const activities = [\n> \t{ name: 'A', start: 1, end: 4 }, // 4시 끝\n> \t{ name: 'B', start: 3, end: 5 }, // 5시 끝\n> \t{ name: 'C', start: 0, end: 6 }, // 6시 끝\n> \t{ name: 'D', start: 5, end: 7 }, // 7시 끝 \n> \t{ name: 'E', start: 8, end: 9 }, // 9시 끝\n> \t{ name: 'F', start: 5, end: 9 } // 9시 끝\n> ];\n> ```\n> ##### 2. 탐욕적 선택 과정\n> ```typescript\n>\tfunction activitySelection(activities) { \n>\t\tactivities.sort((a, b) => a.end - b.end); \n>\t\tconst result = [activities[0]]; // 첫 번째 활동은 무조건 선택 \n>\t\tlet lastEnd = activities[0].end; \n>\t\tfor (let i = 1; i < activities.length; i++) { \n>\t\t\tif (activities[i].start >= lastEnd) { \n>\t\t\t\tresult.push(activities[i]); \n>\t\t\t\tlastEnd = activities[i].end; \n>\t\t\t} \n>\t\t} \n>\t\treturn result; \n>\t}\n> ```\n> \n> <img width=\"425\" height=\"680\" alt=\"image\" src=\"https://github.com/user-attachments/assets/9bb92352-ba34-49e6-8b49-7e396c4fedf4\" />\n> <img width=\"425\" height=\"208\" alt=\"image\" src=\"https://github.com/user-attachments/assets/d581a179-119f-4517-9f38-87b7f942fbf2\" />\n> \n> ```typescript\n> \t// 가장 많은 활동을 선택하기\n> \tfunction activitySelection (activities: {start: number, end: number} [] ) {\n> \t\tactivities.sort((a, b) => a.end - b.end); // 끝나는 시간 순 정렬\n> \t\t\n> \t\tconst result = [activities[0]]; // 첫 번재 활동은 무조건 선택\n> \t\tlet lastEnd = activities[0].end;\n> \t\t\n> \t\tfor (let i = 1; i < activities.length; i++) {\n> \t\t\tif (activities[i].start >= lastEnd) { // 탐욕적 선택: 가장 빨리 끝나는 것\n> \t\t\t\tresult.push(activities[i]);\n> \t\t\t\tlastEnd = activities[i].end;\n> \t\t\t}\n> \t\t}\n> \t\treturn result;\n> \t}\n> ```\n\n#### 3. Two Crystal Balls에서의 탐욕적 접근\n##### 탐욕적 선택들:\n1. √n 간격으로 점프: 가장 효율적인 간격\n2. 깨지면 즉시 중단: 불필요한 테스트 피하기\n3. 이전 안전 지점부터 선형 탐색: 확실한 구간에서만 탐색\n##### 각 단계에서의 \"탐욕적\" 판단:\n1. 1단계: \"지금 당장 가장 빠르게 구간을 좁힐 수 있는 방법은?\"\n2. 2단계: \"남은 볼 1개로 가장 확실하게 찾을 수 있는 방법은?\"\n\n#### 4. 탐욕법의 장단점\n##### 1. 장점\n- 구현이 간단\n- 속도가 빠름\n- 직관적으로 이해하기 쉬움\n##### 2. 단점\n- 항상 최적해를 보장하지 않음\n- 문제에 따라 적용 불가능\n##### 3. 탐욕법이 최적해를 보장하는 조건\n1. 탐욕적 선택 속성: 지역적 최적 선택이 전역적 최적해로 이어짐\n2. 최적 부분 구조: 문제의 최적해가 부분 문제의 최적해를 포함\n##### 4. Two Crystal Balls 문제에서 탐욕법을 쓰는 이유는 √n 간격이 수학적으로 최적이라는 것이 증명되어있기 때문\n\n#### 5. 다른 접근법과의 비교\n<img width=\"535\" height=\"145\" alt=\"image\" src=\"https://github.com/user-attachments/assets/6098f89b-294e-4ff4-9008-3030188e221a\" />"
  },
  {
    "slug": "1-basics",
    "title": "Basics of Algorithm",
    "date": "2026-02-17",
    "category": "Algorithm",
    "tags": [
      "Algorithm",
      "Big O"
    ],
    "description": "An introduction to Big O time complexity — how to classify algorithms by their growth rate, why worst-case analysis matters in interviews, and the difference between edge cases and corner cases.",
    "content": "source: https://frontendmasters.com/courses/algorithms/binary-search-algorithm/\n\n# 1. Big O Time Complexity\n## 1. 기본 개념\n- Big O는 입력값에 따른 알고리즘의 시간이나 메모리를 분류하는 방법\n- 정확한 측정치가 아닌, 입력값이 증가함에 따라 알고리즘이 어떻게 반응하는지 이해하기 위한 일반화된 방법\n- 예를 들어, O(N)는 알고리즘이 입력값에 비례하여 선형적으로 증가한다는 의미\n\n## 2. Big O를 사용하는 이유\n- 특정 데이터 구조를 사용해야 하는지 결정하는 데 도움이 됨\n- 데이터 구조들은 점점 더 효율적으로 만들기 위해 제약 조건을 갖지만, 잘못 사용하면 성능이 크게 저하될 수 있음\n\n## 3. Big O의 중요 개념\n- 입력값에 대한 성장: 입력값이 증가할수록 계산 시간이나 메모리가 어떻게 증가하는지를 나타냄\n- 상수는 무시: 이론적으로 상수는 중요하지 않음\n\t- 예: O(10N) => O(N)\n- 최악의 경우 고려: 인터뷰에서는 주로 최악의 경우를 설명함\n\n> [!IMPORTANT]\n> # 인터뷰에서 Big O의 최악의 경우를 주로 설명하는 이유?\n> ## 1. 신뢰성 보장\n> - 최악의 경우를 고려하면 알고리즘이 어떤 상황에서도 특정 성능 기준을 충족할 것이라고 보장할 수 있음\n> - 이는 시스템의 안정성과 예측 가능성을 높임\n> ## 2. 에지 케이스 처리\n> - 실제 환경에서는 예상치 못한 입력이나 상황이 발생할 수 있음\n> - 최악의 경우를 고려하면 이러한 에지 케이스에도 대응할 수 있는 알고리즘을 설계할 수 있음\n> ## 3. 리소스 계획\n> - 시스템 설계 시 필요한 컴퓨팅 리소스(CPU, 메모리 등)를 계획할 때 최악의 경우를 고려해야 함\n> - 예를 들어, 웹 서비스가 순간적으로 트래픽이 폭증하는 상황에도 대응할 수 있어야 함\n> ## 4. 확인하기 쉬움\n> - 최악의 경우는 일반적으로 정의하고 분석하기가 더 명확함\n> - 평균 케이스는 입력 분포에 따라 달라질 수 있어 더 복잡한 분석이 필요함\n> ## 5. 실용적 측면\n> - 강의에서 언급했듯이, 강사는 약 200번의 인터뷰를 진행하고 50번의 인터뷰에 참여했지만 최선이나 평균 케이스를 묻는 경우는 거의 없었다고 함\n> - 이는 업계 관행에서 최악의 케이스가 더 중요하게 여겨진다는 것을 보여줌\n> \n> 예시를 들면:\n> - 문자열에서 특정 문자('E')를 찾는 알고리즘에서, 최악의 경우는 문자가 문자열의 끝에 있거나 아예 없는 경우로, 전체 문자열을 탐색해야 하므로 O(N)\n> - 최선의 경우는 문자가 첫 번째에 있어 O(1)이 되지만, 이런 이상적인 상황에만 의존할 수 없음\n> \n> 실제 소프트웨어 개발에서는 시스템이 최악의 상황에서도 견딜 수 있어야 하기 때문에, 인터뷰에서도 이런 관점에서 알고리즘을 평가하는 것\n\n> [!INFO]\n> # Edge Case와 Corner Case\n> ## 1. Edge Case\n> - 엣지 케이스는 알고리즘이나 프로그램이 정상적인 동작 범위의 '가장자리(edge)'에 있는 입력이나 상황을 의미\n> ### 1. 특징\n> - 일반적인 사용 패턴에서 벗어나지만, 여전히 유효한 입력\n> - 기본 로직이 처리하지 못할 수 있는 경계값(boundary value)에 해당함\n> - 프로그램의 정상 동작 범위 내에서 예외적인 상황\n> ### 2. 예시\n> #### 1. 배열 처리: 빈 배열, 단일 요소 배열\n> #### 2. 숫자 연산: 0으로 나누기, 최대/최소 정수값 처리\n> #### 3. 문자열 처리: 빈 문자열, 매우 긴 문자열\n> #### 4. 날짜 처리: 윤년, 월말 날짜\n> #### 5. 사용자 입력: 예상치 못한 형식의 입력(특수 문자, 이모지 등)\n> ## 2. Corner Case\n> 코너 케이스는 여러 엣지 케이스가 동시에 발생하거나 더 극단적인 상황을 의미함\n> '코너(corner)'라는 이름은 여러 경계값이 만나는 지점, 즉 '모서리'에서 발생하는 케이스라는 의미에서 유래함\n> ### 1. 특징\n> - 여러 엣지 케이스의 조합으로 발생하는 더 복잡한 상황\n> - 매우 드물게 발생하지만, 발생 시 심각한 문제를 일으킬 수 있음\n> - 테스트하기 어려운 경우가 많음\n> ### 2. 예시\n> #### 1. 웹 애플리케이션: 네트워크 연결이 불안정한 상태에서 대용량 파일 업로드\n> #### 2. 모바일 앱: 배터리가 거의 없는 상태에서 GPS와 카메라를 동시에 사용\n> #### 3. 데이터베이스: 최대 연결 수에 도달한 상태에서 대량의 트랜잭션 처리\n> #### 4. 알고리즘: 정렬 알고리즘에서 이미 정렬된 역순 배열 처리\n> #### 5. UI: 매우 작은 화면에서 복잡한 대화상자 표시\n> ## 3. 두 개념의 차이점\n> ### 1. 범위와 복잡성\n> - 엣지 케이스: 단일 변수나 조건의 경계값\n> - 코너 케이스: 여러 변수나 조건의 경계값이 동시에 발생\n> ### 2. 발생 빈도\n> - 엣지 케이스: 상대적으로 더 자주 발생\n> - 코너 케이스: 매우 드물게 발생\n> ### 3. 예측 가능성\n> - 엣지 케이스: 비교적 예측하기 쉬움\n> - 코너 케이스: 예측하기 어려움\n> ## 4. 소프트웨어 개발에서의 중요성\n> ### 1. 견고한 시스템 구축: 엣지 케이스와 코너 케이스를 처리하면 더 안정적인 소프트웨어를 만들 수 있음\n> ### 2. 버그 예방: 이러한 케이스를 미리 고려하면 나중에 발생할 수 있는 심각한 오류를 예방할 수 있음\n> ### 3. 사용자 경험 향상: 예상치 못한 상황에서도 적절히 대응하여 사용자 만족도를 높일 수 있음\n> ### 4. 유지보수 비용 절감: 사후에 발견되는 버그를 수정하는 것보다 개발 단계에서 이러한 케이스를 고려하는 것이 비용 효율적임\n> \n> 엣지 케이스와 코너 케이스를 철저히 테스트하고 처리하는 것은 고품질 소프트웨어 개발의 핵심 요소\n> \n\n## 4. 일반적인 복잡도\n- O(1): 상수 시간 - 입력 크기와 관계없이 항상 동일한 작업 수행\n- O(log N): 로그 시간 - 이진 검색 등의 알고리즘\n- O(N): 선형 시간 - 입력 크기에 비례하여 증가\n- O(N log N): 퀵소트와 같은 정렬 알고리즘\n- O(N²): 제곱 시간 - 이중 반복문 등\n- O(N³): 세제곱 시간 - 행렬 곱셈 등\n- O(2^N), O(N!): 실용적이지 않은 알고리즘\n\n## 5. 복잡도 파악하는 법\n- 반복문을 찾기: 입력값에 대해 어떻게 반복하는지 확인하는 것이 가장 쉬운 방법\n- 예: 문자열의 길이만큼 반복하는 반복문은 O(N)\n- 중첩 반복문은 각 차원에 따라 복잡도가 증가 (예: 이중 반복문은 O(N²))\n\n## 6. 공간 복잡도\n- 시간 복잡도만큼 자주 논의되지는 않지만, 특정 상황에서는 중요할 수 있음\n- 알고리즘이 사용하는 메모리가 입력값에 따라 어떻게 증가하는지를 나타냄\n\n## 7. 퀵소트, 링 버퍼(실용적으로 유용함)"
  }
];
