---
title: "Basics of Algorithm"
slug: "1-basics"
date: "2026-02-17"
category: "Algorithm"
tags: ["Algorithm", "Big O"]
description: "An introduction to Big O time complexity — how to classify algorithms by their growth rate, why worst-case analysis matters in interviews, and the difference between edge cases and corner cases."
---

source: https://frontendmasters.com/courses/algorithms/binary-search-algorithm/

# 1. Big O Time Complexity
## 1. 기본 개념
- Big O는 입력값에 따른 알고리즘의 시간이나 메모리를 분류하는 방법
- 정확한 측정치가 아닌, 입력값이 증가함에 따라 알고리즘이 어떻게 반응하는지 이해하기 위한 일반화된 방법
- 예를 들어, O(N)는 알고리즘이 입력값에 비례하여 선형적으로 증가한다는 의미

## 2. Big O를 사용하는 이유
- 특정 데이터 구조를 사용해야 하는지 결정하는 데 도움이 됨
- 데이터 구조들은 점점 더 효율적으로 만들기 위해 제약 조건을 갖지만, 잘못 사용하면 성능이 크게 저하될 수 있음

## 3. Big O의 중요 개념
- 입력값에 대한 성장: 입력값이 증가할수록 계산 시간이나 메모리가 어떻게 증가하는지를 나타냄
- 상수는 무시: 이론적으로 상수는 중요하지 않음
	- 예: O(10N) => O(N)
- 최악의 경우 고려: 인터뷰에서는 주로 최악의 경우를 설명함

> [!IMPORTANT]
> # 인터뷰에서 Big O의 최악의 경우를 주로 설명하는 이유?
> ## 1. 신뢰성 보장
> - 최악의 경우를 고려하면 알고리즘이 어떤 상황에서도 특정 성능 기준을 충족할 것이라고 보장할 수 있음
> - 이는 시스템의 안정성과 예측 가능성을 높임
> ## 2. 에지 케이스 처리
> - 실제 환경에서는 예상치 못한 입력이나 상황이 발생할 수 있음
> - 최악의 경우를 고려하면 이러한 에지 케이스에도 대응할 수 있는 알고리즘을 설계할 수 있음
> ## 3. 리소스 계획
> - 시스템 설계 시 필요한 컴퓨팅 리소스(CPU, 메모리 등)를 계획할 때 최악의 경우를 고려해야 함
> - 예를 들어, 웹 서비스가 순간적으로 트래픽이 폭증하는 상황에도 대응할 수 있어야 함
> ## 4. 확인하기 쉬움
> - 최악의 경우는 일반적으로 정의하고 분석하기가 더 명확함
> - 평균 케이스는 입력 분포에 따라 달라질 수 있어 더 복잡한 분석이 필요함
> ## 5. 실용적 측면
> - 강의에서 언급했듯이, 강사는 약 200번의 인터뷰를 진행하고 50번의 인터뷰에 참여했지만 최선이나 평균 케이스를 묻는 경우는 거의 없었다고 함
> - 이는 업계 관행에서 최악의 케이스가 더 중요하게 여겨진다는 것을 보여줌
> 
> 예시를 들면:
> - 문자열에서 특정 문자('E')를 찾는 알고리즘에서, 최악의 경우는 문자가 문자열의 끝에 있거나 아예 없는 경우로, 전체 문자열을 탐색해야 하므로 O(N)
> - 최선의 경우는 문자가 첫 번째에 있어 O(1)이 되지만, 이런 이상적인 상황에만 의존할 수 없음
> 
> 실제 소프트웨어 개발에서는 시스템이 최악의 상황에서도 견딜 수 있어야 하기 때문에, 인터뷰에서도 이런 관점에서 알고리즘을 평가하는 것

> [!INFO]
> # Edge Case와 Corner Case
> ## 1. Edge Case
> - 엣지 케이스는 알고리즘이나 프로그램이 정상적인 동작 범위의 '가장자리(edge)'에 있는 입력이나 상황을 의미
> ### 1. 특징
> - 일반적인 사용 패턴에서 벗어나지만, 여전히 유효한 입력
> - 기본 로직이 처리하지 못할 수 있는 경계값(boundary value)에 해당함
> - 프로그램의 정상 동작 범위 내에서 예외적인 상황
> ### 2. 예시
> #### 1. 배열 처리: 빈 배열, 단일 요소 배열
> #### 2. 숫자 연산: 0으로 나누기, 최대/최소 정수값 처리
> #### 3. 문자열 처리: 빈 문자열, 매우 긴 문자열
> #### 4. 날짜 처리: 윤년, 월말 날짜
> #### 5. 사용자 입력: 예상치 못한 형식의 입력(특수 문자, 이모지 등)
> ## 2. Corner Case
> 코너 케이스는 여러 엣지 케이스가 동시에 발생하거나 더 극단적인 상황을 의미함
> '코너(corner)'라는 이름은 여러 경계값이 만나는 지점, 즉 '모서리'에서 발생하는 케이스라는 의미에서 유래함
> ### 1. 특징
> - 여러 엣지 케이스의 조합으로 발생하는 더 복잡한 상황
> - 매우 드물게 발생하지만, 발생 시 심각한 문제를 일으킬 수 있음
> - 테스트하기 어려운 경우가 많음
> ### 2. 예시
> #### 1. 웹 애플리케이션: 네트워크 연결이 불안정한 상태에서 대용량 파일 업로드
> #### 2. 모바일 앱: 배터리가 거의 없는 상태에서 GPS와 카메라를 동시에 사용
> #### 3. 데이터베이스: 최대 연결 수에 도달한 상태에서 대량의 트랜잭션 처리
> #### 4. 알고리즘: 정렬 알고리즘에서 이미 정렬된 역순 배열 처리
> #### 5. UI: 매우 작은 화면에서 복잡한 대화상자 표시
> ## 3. 두 개념의 차이점
> ### 1. 범위와 복잡성
> - 엣지 케이스: 단일 변수나 조건의 경계값
> - 코너 케이스: 여러 변수나 조건의 경계값이 동시에 발생
> ### 2. 발생 빈도
> - 엣지 케이스: 상대적으로 더 자주 발생
> - 코너 케이스: 매우 드물게 발생
> ### 3. 예측 가능성
> - 엣지 케이스: 비교적 예측하기 쉬움
> - 코너 케이스: 예측하기 어려움
> ## 4. 소프트웨어 개발에서의 중요성
> ### 1. 견고한 시스템 구축: 엣지 케이스와 코너 케이스를 처리하면 더 안정적인 소프트웨어를 만들 수 있음
> ### 2. 버그 예방: 이러한 케이스를 미리 고려하면 나중에 발생할 수 있는 심각한 오류를 예방할 수 있음
> ### 3. 사용자 경험 향상: 예상치 못한 상황에서도 적절히 대응하여 사용자 만족도를 높일 수 있음
> ### 4. 유지보수 비용 절감: 사후에 발견되는 버그를 수정하는 것보다 개발 단계에서 이러한 케이스를 고려하는 것이 비용 효율적임
> 
> 엣지 케이스와 코너 케이스를 철저히 테스트하고 처리하는 것은 고품질 소프트웨어 개발의 핵심 요소
> 

## 4. 일반적인 복잡도
- O(1): 상수 시간 - 입력 크기와 관계없이 항상 동일한 작업 수행
- O(log N): 로그 시간 - 이진 검색 등의 알고리즘
- O(N): 선형 시간 - 입력 크기에 비례하여 증가
- O(N log N): 퀵소트와 같은 정렬 알고리즘
- O(N²): 제곱 시간 - 이중 반복문 등
- O(N³): 세제곱 시간 - 행렬 곱셈 등
- O(2^N), O(N!): 실용적이지 않은 알고리즘

## 5. 복잡도 파악하는 법
- 반복문을 찾기: 입력값에 대해 어떻게 반복하는지 확인하는 것이 가장 쉬운 방법
- 예: 문자열의 길이만큼 반복하는 반복문은 O(N)
- 중첩 반복문은 각 차원에 따라 복잡도가 증가 (예: 이중 반복문은 O(N²))

## 6. 공간 복잡도
- 시간 복잡도만큼 자주 논의되지는 않지만, 특정 상황에서는 중요할 수 있음
- 알고리즘이 사용하는 메모리가 입력값에 따라 어떻게 증가하는지를 나타냄

## 7. 퀵소트, 링 버퍼(실용적으로 유용함)
